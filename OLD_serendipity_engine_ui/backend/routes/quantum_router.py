#!/usr/bin/env python3\n\"\"\"\nQuantum Router - FastAPI routes for quantum operations\n====================================================\n\nDefines API endpoints for quantum collapse operations.\n\"\"\"\n\nimport logging\nimport uuid\nimport asyncio\nfrom typing import List, Optional\nfrom datetime import datetime\n\nfrom fastapi import APIRouter, HTTPException, BackgroundTasks, Depends\nfrom fastapi.responses import JSONResponse\n\nfrom models.quantum_models import (\n    CollapseRequest,\n    CollapseResponse,\n    HardwareStatusResponse,\n    DeviceTestRequest,\n    DeviceTestResponse,\n    ValidationRequest,\n    ValidationResponse,\n    BatchCollapseRequest,\n    BatchCollapseResponse,\n    ErrorResponse\n)\nfrom services.quantum_service import QuantumService\nfrom services.hardware_service import HardwareService\n\nlogger = logging.getLogger(__name__)\n\n# Create router\nrouter = APIRouter()\n\n# Initialize services\nquantum_service = QuantumService()\nhardware_service = HardwareService()\n\n\n@router.post(\"/collapse\", response_model=CollapseResponse)\nasync def quantum_collapse(\n    request: CollapseRequest,\n    background_tasks: BackgroundTasks\n) -> CollapseResponse:\n    \"\"\"Perform quantum collapse tiebreaker operation\"\"\"\n    \n    logger.info(f\"üéØ Quantum collapse request: {len(request.candidate_vectors)} candidates\")\n    \n    try:\n        # Process the collapse\n        result = await quantum_service.perform_collapse(request)\n        \n        # Log metrics in background\n        background_tasks.add_task(\n            log_operation_metrics,\n            \"collapse\",\n            result.processing_time,\n            result.hardware_used\n        )\n        \n        return result\n        \n    except ValueError as e:\n        logger.warning(f\"‚ùå Validation error: {e}\")\n        raise HTTPException(status_code=400, detail=str(e))\n    \n    except TimeoutError as e:\n        logger.error(f\"‚è∞ Timeout error: {e}\")\n        raise HTTPException(status_code=504, detail=\"Operation timeout\")\n    \n    except Exception as e:\n        logger.error(f\"‚ùå Collapse operation failed: {e}\")\n        raise HTTPException(status_code=500, detail=\"Quantum collapse failed\")\n\n\n@router.post(\"/batch_collapse\", response_model=BatchCollapseResponse)\nasync def batch_quantum_collapse(\n    request: BatchCollapseRequest,\n    background_tasks: BackgroundTasks\n) -> BatchCollapseResponse:\n    \"\"\"Perform batch quantum collapse operations\"\"\"\n    \n    batch_id = str(uuid.uuid4())\n    start_time = datetime.utcnow()\n    \n    logger.info(f\"üîÄ Batch collapse request: {len(request.requests)} operations\")\n    \n    try:\n        results = []\n        success_count = 0\n        failure_count = 0\n        \n        if request.parallel_execution:\n            # Process requests in parallel\n            semaphore = asyncio.Semaphore(request.max_concurrency or 3)\n            \n            async def process_single_request(single_request: CollapseRequest):\n                async with semaphore:\n                    try:\n                        result = await quantum_service.perform_collapse(single_request)\n                        return result, None\n                    except Exception as e:\n                        return None, str(e)\n            \n            tasks = [process_single_request(req) for req in request.requests]\n            task_results = await asyncio.gather(*tasks, return_exceptions=True)\n            \n            for i, (result, error) in enumerate(task_results):\n                if error is None and result is not None:\n                    results.append(result)\n                    success_count += 1\n                else:\n                    failure_count += 1\n                    \n                    if request.failure_strategy == \"abort\":\n                        raise HTTPException(\n                            status_code=500,\n                            detail=f\"Batch aborted at request {i}: {error}\"\n                        )\n                    \n                    # Create error response for failed request\n                    error_response = CollapseResponse(\n                        success=False,\n                        selected_index=-1,\n                        confidence=0.0,\n                        quantum_kernel=[],\n                        hardware_used=False,\n                        device=\"error\",\n                        shots=0,\n                        method=\"none\",\n                        processing_time=0.0,\n                        timestamp=datetime.utcnow().isoformat() + \"Z\"\n                    )\n                    results.append(error_response)\n        \n        else:\n            # Process requests sequentially\n            for i, single_request in enumerate(request.requests):\n                try:\n                    result = await quantum_service.perform_collapse(single_request)\n                    results.append(result)\n                    success_count += 1\n                    \n                except Exception as e:\n                    failure_count += 1\n                    \n                    if request.failure_strategy == \"abort\":\n                        raise HTTPException(\n                            status_code=500,\n                            detail=f\"Batch aborted at request {i}: {e}\"\n                        )\n                    \n                    # Add error response\n                    error_response = CollapseResponse(\n                        success=False,\n                        selected_index=-1,\n                        confidence=0.0,\n                        quantum_kernel=[],\n                        hardware_used=False,\n                        device=\"error\",\n                        shots=0,\n                        method=\"none\",\n                        processing_time=0.0,\n                        timestamp=datetime.utcnow().isoformat() + \"Z\"\n                    )\n                    results.append(error_response)\n        \n        # Calculate total processing time\n        total_time = (datetime.utcnow() - start_time).total_seconds() * 1000\n        \n        # Log batch metrics\n        background_tasks.add_task(\n            log_batch_metrics,\n            batch_id,\n            len(request.requests),\n            success_count,\n            failure_count,\n            total_time\n        )\n        \n        return BatchCollapseResponse(\n            success=(failure_count == 0),\n            results=results,\n            total_processing_time=total_time,\n            success_count=success_count,\n            failure_count=failure_count,\n            batch_id=batch_id,\n            timestamp=datetime.utcnow().isoformat() + \"Z\"\n        )\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"‚ùå Batch collapse failed: {e}\")\n        raise HTTPException(status_code=500, detail=\"Batch operation failed\")\n\n\n@router.get(\"/hardware/status\", response_model=HardwareStatusResponse)\nasync def get_hardware_status() -> HardwareStatusResponse:\n    \"\"\"Get current quantum hardware status\"\"\"\n    \n    try:\n        status_dict = await hardware_service.get_status()\n        \n        return HardwareStatusResponse(**status_dict)\n        \n    except Exception as e:\n        logger.error(f\"‚ùå Hardware status check failed: {e}\")\n        raise HTTPException(status_code=500, detail=\"Hardware status unavailable\")\n\n\n@router.post(\"/hardware/test\", response_model=DeviceTestResponse)\nasync def test_device_connection(\n    request: DeviceTestRequest\n) -> DeviceTestResponse:\n    \"\"\"Test connection to a quantum device\"\"\"\n    \n    try:\n        result = await hardware_service.test_device_connection(request.device)\n        \n        return DeviceTestResponse(**result)\n        \n    except Exception as e:\n        logger.error(f\"‚ùå Device test failed: {e}\")\n        raise HTTPException(status_code=500, detail=\"Device test failed\")\n\n\n@router.post(\"/hardware/validate\", response_model=ValidationResponse)\nasync def validate_parameters(\n    request: ValidationRequest\n) -> ValidationResponse:\n    \"\"\"Validate quantum circuit parameters\"\"\"\n    \n    try:\n        result = await hardware_service.validate_parameters(\n            request.wires,\n            request.shots,\n            request.device\n        )\n        \n        return ValidationResponse(**result)\n        \n    except Exception as e:\n        logger.error(f\"‚ùå Parameter validation failed: {e}\")\n        raise HTTPException(status_code=500, detail=\"Parameter validation failed\")\n\n\n@router.get(\"/hardware/devices\")\nasync def get_available_devices():\n    \"\"\"Get list of available quantum devices\"\"\"\n    \n    try:\n        status = await hardware_service.get_status()\n        \n        return {\n            \"devices\": status.get(\"devices\", []),\n            \"default_device\": status.get(\"device\", \"unknown\"),\n            \"timestamp\": datetime.utcnow().isoformat() + \"Z\"\n        }\n        \n    except Exception as e:\n        logger.error(f\"‚ùå Device list retrieval failed: {e}\")\n        raise HTTPException(status_code=500, detail=\"Device list unavailable\")\n\n\n@router.get(\"/hardware/recommend\")\nasync def get_recommended_device(\n    wires: int,\n    shots: int\n):\n    \"\"\"Get recommended device for given parameters\"\"\"\n    \n    try:\n        if not (1 <= wires <= 20):\n            raise HTTPException(status_code=400, detail=\"Wires must be between 1 and 20\")\n        \n        if not (1 <= shots <= 100000):\n            raise HTTPException(status_code=400, detail=\"Shots must be between 1 and 100000\")\n        \n        recommended_device = await hardware_service.get_recommended_device(wires, shots)\n        \n        return {\n            \"recommended_device\": recommended_device,\n            \"wires\": wires,\n            \"shots\": shots,\n            \"timestamp\": datetime.utcnow().isoformat() + \"Z\"\n        }\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"‚ùå Device recommendation failed: {e}\")\n        raise HTTPException(status_code=500, detail=\"Device recommendation failed\")\n\n\n@router.get(\"/metrics\")\nasync def get_service_metrics():\n    \"\"\"Get quantum service metrics\"\"\"\n    \n    try:\n        metrics = await quantum_service.get_metrics()\n        hardware_status = await hardware_service.get_status()\n        \n        return {\n            \"quantum_service\": metrics,\n            \"hardware_status\": {\n                \"available\": hardware_status.get(\"hardware_available\", False),\n                \"device\": hardware_status.get(\"device\", \"unknown\"),\n                \"status\": hardware_status.get(\"status\", \"unknown\")\n            },\n            \"timestamp\": datetime.utcnow().isoformat() + \"Z\"\n        }\n        \n    except Exception as e:\n        logger.error(f\"‚ùå Metrics collection failed: {e}\")\n        raise HTTPException(status_code=500, detail=\"Metrics unavailable\")\n\n\n@router.post(\"/hardware/cache/clear\")\nasync def clear_hardware_cache():\n    \"\"\"Clear cached hardware status\"\"\"\n    \n    try:\n        hardware_service.clear_cache()\n        \n        return {\n            \"success\": True,\n            \"message\": \"Hardware cache cleared\",\n            \"timestamp\": datetime.utcnow().isoformat() + \"Z\"\n        }\n        \n    except Exception as e:\n        logger.error(f\"‚ùå Cache clear failed: {e}\")\n        raise HTTPException(status_code=500, detail=\"Cache clear failed\")\n\n\n# Background task functions\nasync def log_operation_metrics(\n    operation_type: str,\n    processing_time: float,\n    hardware_used: bool\n) -> None:\n    \"\"\"Log operation metrics in the background\"\"\"\n    \n    logger.info(\n        f\"üìä Metrics - Operation: {operation_type}, \"\n        f\"Time: {processing_time:.2f}ms, \"\n        f\"Hardware: {hardware_used}\"\n    )\n\n\nasync def log_batch_metrics(\n    batch_id: str,\n    total_requests: int,\n    success_count: int,\n    failure_count: int,\n    total_time: float\n) -> None:\n    \"\"\"Log batch operation metrics\"\"\"\n    \n    logger.info(\n        f\"üìä Batch Metrics - ID: {batch_id}, \"\n        f\"Total: {total_requests}, Success: {success_count}, \"\n        f\"Failed: {failure_count}, Time: {total_time:.2f}ms\"\n    )\n"