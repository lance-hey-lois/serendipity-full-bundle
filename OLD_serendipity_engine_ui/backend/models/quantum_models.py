#!/usr/bin/env python3\n\"\"\"\nQuantum Models - Pydantic models for API requests/responses\n==========================================================\n\nDefines the data models for quantum collapse operations.\n\"\"\"\n\nfrom typing import List, Optional, Dict, Any, Literal\nfrom pydantic import BaseModel, Field, validator\nimport numpy as np\n\n\nclass CollapseRequest(BaseModel):\n    \"\"\"Request model for quantum collapse operation\"\"\"\n    \n    seed_vector: List[float] = Field(\n        ..., \n        description=\"Reference vector for quantum kernel computation\",\n        min_items=1,\n        max_items=1024\n    )\n    \n    candidate_vectors: List[List[float]] = Field(\n        ...,\n        description=\"List of candidate vectors to compare against seed\",\n        min_items=1, \n        max_items=100\n    )\n    \n    use_hardware: bool = Field(\n        default=True,\n        description=\"Whether to attempt quantum hardware execution\"\n    )\n    \n    max_shots: Optional[int] = Field(\n        default=1000,\n        description=\"Maximum number of quantum shots for hardware execution\",\n        ge=10,\n        le=10000\n    )\n    \n    method: Optional[Literal[\"kernel_fidelity\", \"amplitude_encoding\", \"angle_encoding\"]] = Field(\n        default=\"kernel_fidelity\",\n        description=\"Quantum encoding method to use\"\n    )\n    \n    device_preference: Optional[str] = Field(\n        default=None,\n        description=\"Preferred quantum device (e.g., 'X8', 'local_simulator')\"\n    )\n    \n    timeout: Optional[int] = Field(\n        default=30,\n        description=\"Operation timeout in seconds\",\n        ge=1,\n        le=300\n    )\n    \n    @validator('candidate_vectors')\n    def validate_candidate_dimensions(cls, v, values):\n        \"\"\"Ensure all candidate vectors have same dimension as seed vector\"\"\"\n        if 'seed_vector' in values:\n            seed_dim = len(values['seed_vector'])\n            for i, candidate in enumerate(v):\n                if len(candidate) != seed_dim:\n                    raise ValueError(\n                        f\"Candidate vector {i} has dimension {len(candidate)}, \"\n                        f\"expected {seed_dim}\"\n                    )\n        return v\n    \n    @validator('seed_vector', 'candidate_vectors')\n    def validate_finite_values(cls, v):\n        \"\"\"Ensure all values are finite numbers\"\"\"\n        if isinstance(v, list) and len(v) > 0 and isinstance(v[0], list):\n            # candidate_vectors case\n            for vec_idx, vector in enumerate(v):\n                for val_idx, value in enumerate(vector):\n                    if not np.isfinite(value):\n                        raise ValueError(\n                            f\"Invalid value at candidate_vectors[{vec_idx}][{val_idx}]: {value}\"\n                        )\n        else:\n            # seed_vector case\n            for idx, value in enumerate(v):\n                if not np.isfinite(value):\n                    raise ValueError(f\"Invalid value at seed_vector[{idx}]: {value}\")\n        return v\n\n\nclass CollapseResponse(BaseModel):\n    \"\"\"Response model for quantum collapse operation\"\"\"\n    \n    success: bool = Field(\n        description=\"Whether the operation completed successfully\"\n    )\n    \n    selected_index: int = Field(\n        description=\"Index of the selected candidate vector\"\n    )\n    \n    confidence: float = Field(\n        description=\"Confidence score for the selection (0-1)\",\n        ge=0.0,\n        le=1.0\n    )\n    \n    quantum_kernel: List[float] = Field(\n        description=\"Quantum kernel values for each candidate\"\n    )\n    \n    hardware_used: bool = Field(\n        description=\"Whether quantum hardware was used for computation\"\n    )\n    \n    device: str = Field(\n        description=\"Device used for computation\"\n    )\n    \n    shots: int = Field(\n        description=\"Number of quantum shots used (0 for exact simulation)\"\n    )\n    \n    method: str = Field(\n        description=\"Quantum method used for computation\"\n    )\n    \n    processing_time: float = Field(\n        description=\"Processing time in milliseconds\"\n    )\n    \n    timestamp: str = Field(\n        description=\"ISO timestamp of the operation\"\n    )\n    \n    statistics: Optional[Dict[str, float]] = Field(\n        default=None,\n        description=\"Statistical analysis of quantum kernel values\"\n    )\n    \n    metadata: Optional[Dict[str, Any]] = Field(\n        default=None,\n        description=\"Additional metadata about the operation\"\n    )\n\n\nclass DeviceInfo(BaseModel):\n    \"\"\"Information about a quantum device\"\"\"\n    \n    name: str = Field(\n        description=\"Device name/identifier\"\n    )\n    \n    type: Literal[\"photonic\", \"simulator\", \"gate\"] = Field(\n        description=\"Type of quantum device\"\n    )\n    \n    wires: int = Field(\n        description=\"Number of qubits/modes supported\"\n    )\n    \n    available: bool = Field(\n        description=\"Whether the device is currently available\"\n    )\n    \n    queue_size: int = Field(\n        description=\"Number of jobs in queue\",\n        ge=0\n    )\n    \n    specifications: Optional[Dict[str, Any]] = Field(\n        default=None,\n        description=\"Device-specific specifications\"\n    )\n\n\nclass HardwareStatusResponse(BaseModel):\n    \"\"\"Response model for hardware status\"\"\"\n    \n    status: Literal[\"operational\", \"degraded\", \"offline\", \"error\"] = Field(\n        description=\"Overall hardware status\"\n    )\n    \n    hardware_available: bool = Field(\n        description=\"Whether quantum hardware is available\"\n    )\n    \n    device: str = Field(\n        description=\"Current default device\"\n    )\n    \n    authenticated: bool = Field(\n        description=\"Whether API authentication is successful\"\n    )\n    \n    api_key_set: bool = Field(\n        description=\"Whether API key is configured\"\n    )\n    \n    max_shots: int = Field(\n        description=\"Maximum shots allowed per job\"\n    )\n    \n    max_wires: int = Field(\n        description=\"Maximum wires/qubits supported\"\n    )\n    \n    devices: List[DeviceInfo] = Field(\n        description=\"List of available devices\"\n    )\n    \n    last_check: str = Field(\n        description=\"Timestamp of last status check\"\n    )\n    \n    modules_available: bool = Field(\n        description=\"Whether quantum modules are properly loaded\"\n    )\n    \n    error: Optional[str] = Field(\n        default=None,\n        description=\"Error message if status check failed\"\n    )\n\n\nclass DeviceTestRequest(BaseModel):\n    \"\"\"Request model for device connection test\"\"\"\n    \n    device: str = Field(\n        description=\"Device name to test\"\n    )\n    \n    test_shots: Optional[int] = Field(\n        default=10,\n        description=\"Number of shots for test circuit\",\n        ge=1,\n        le=100\n    )\n    \n    timeout: Optional[int] = Field(\n        default=30,\n        description=\"Test timeout in seconds\",\n        ge=1,\n        le=120\n    )\n\n\nclass DeviceTestResponse(BaseModel):\n    \"\"\"Response model for device connection test\"\"\"\n    \n    success: bool = Field(\n        description=\"Whether the test was successful\"\n    )\n    \n    device: str = Field(\n        description=\"Device that was tested\"\n    )\n    \n    latency: float = Field(\n        description=\"Test latency in milliseconds\"\n    )\n    \n    test_result: Optional[float] = Field(\n        default=None,\n        description=\"Result of test quantum computation\"\n    )\n    \n    message: str = Field(\n        description=\"Human-readable test result message\"\n    )\n    \n    error: Optional[str] = Field(\n        default=None,\n        description=\"Error message if test failed\"\n    )\n\n\nclass HealthResponse(BaseModel):\n    \"\"\"Response model for health check\"\"\"\n    \n    status: Literal[\"healthy\", \"degraded\", \"unhealthy\"] = Field(\n        description=\"Overall system health status\"\n    )\n    \n    services: Dict[str, bool] = Field(\n        description=\"Health status of individual services\"\n    )\n    \n    version: str = Field(\n        description=\"API version\"\n    )\n    \n    timestamp: str = Field(\n        description=\"Health check timestamp\"\n    )\n    \n    error: Optional[str] = Field(\n        default=None,\n        description=\"Error message if health check failed\"\n    )\n\n\nclass BatchCollapseRequest(BaseModel):\n    \"\"\"Request model for batch quantum collapse operations\"\"\"\n    \n    requests: List[CollapseRequest] = Field(\n        ...,\n        description=\"List of collapse requests to process\",\n        min_items=1,\n        max_items=10\n    )\n    \n    parallel_execution: bool = Field(\n        default=True,\n        description=\"Whether to execute requests in parallel\"\n    )\n    \n    max_concurrency: Optional[int] = Field(\n        default=3,\n        description=\"Maximum concurrent executions\",\n        ge=1,\n        le=10\n    )\n    \n    failure_strategy: Literal[\"abort\", \"continue\", \"retry\"] = Field(\n        default=\"continue\",\n        description=\"How to handle individual request failures\"\n    )\n\n\nclass BatchCollapseResponse(BaseModel):\n    \"\"\"Response model for batch quantum collapse operations\"\"\"\n    \n    success: bool = Field(\n        description=\"Whether the batch operation completed\"\n    )\n    \n    results: List[CollapseResponse] = Field(\n        description=\"Results for each request in the batch\"\n    )\n    \n    total_processing_time: float = Field(\n        description=\"Total batch processing time in milliseconds\"\n    )\n    \n    success_count: int = Field(\n        description=\"Number of successful operations\"\n    )\n    \n    failure_count: int = Field(\n        description=\"Number of failed operations\"\n    )\n    \n    batch_id: str = Field(\n        description=\"Unique identifier for the batch operation\"\n    )\n    \n    timestamp: str = Field(\n        description=\"Batch completion timestamp\"\n    )\n\n\nclass ValidationRequest(BaseModel):\n    \"\"\"Request model for parameter validation\"\"\"\n    \n    wires: int = Field(\n        description=\"Number of quantum wires/qubits\",\n        ge=1,\n        le=20\n    )\n    \n    shots: int = Field(\n        description=\"Number of quantum shots\",\n        ge=1,\n        le=100000\n    )\n    \n    device: Optional[str] = Field(\n        default=None,\n        description=\"Target device for validation\"\n    )\n\n\nclass ValidationResponse(BaseModel):\n    \"\"\"Response model for parameter validation\"\"\"\n    \n    valid: bool = Field(\n        description=\"Whether parameters are valid\"\n    )\n    \n    adjusted_wires: int = Field(\n        description=\"Adjusted wire count for hardware constraints\"\n    )\n    \n    adjusted_shots: int = Field(\n        description=\"Adjusted shot count for hardware constraints\"\n    )\n    \n    adjusted_cutoff: Optional[int] = Field(\n        default=None,\n        description=\"Adjusted cutoff dimension for photonic devices\"\n    )\n    \n    warnings: List[str] = Field(\n        default=[],\n        description=\"List of parameter adjustment warnings\"\n    )\n    \n    error: Optional[str] = Field(\n        default=None,\n        description=\"Error message if validation failed\"\n    )\n\n\nclass ErrorResponse(BaseModel):\n    \"\"\"Standard error response model\"\"\"\n    \n    error: str = Field(\n        description=\"Error type/category\"\n    )\n    \n    message: str = Field(\n        description=\"Human-readable error message\"\n    )\n    \n    detail: Optional[str] = Field(\n        default=None,\n        description=\"Detailed error information\"\n    )\n    \n    status_code: int = Field(\n        description=\"HTTP status code\"\n    )\n    \n    timestamp: str = Field(\n        description=\"Error timestamp\"\n    )\n    \n    request_id: Optional[str] = Field(\n        default=None,\n        description=\"Request identifier for debugging\"\n    )\n\n\n# Utility function for model validation\ndef validate_quantum_vectors(seed: List[float], candidates: List[List[float]]) -> None:\n    \"\"\"Validate quantum vector inputs\"\"\"\n    \n    # Check seed vector\n    if not seed or len(seed) == 0:\n        raise ValueError(\"Seed vector cannot be empty\")\n    \n    if len(seed) > 1024:\n        raise ValueError(\"Seed vector too large (max 1024 dimensions)\")\n    \n    # Check candidates\n    if not candidates or len(candidates) == 0:\n        raise ValueError(\"Candidate vectors cannot be empty\")\n    \n    if len(candidates) > 100:\n        raise ValueError(\"Too many candidate vectors (max 100)\")\n    \n    seed_dim = len(seed)\n    \n    for i, candidate in enumerate(candidates):\n        if len(candidate) != seed_dim:\n            raise ValueError(\n                f\"Candidate {i} dimension mismatch: {len(candidate)} != {seed_dim}\"\n            )\n    \n    # Validate all values are finite\n    all_values = seed + [val for vec in candidates for val in vec]\n    \n    for i, value in enumerate(all_values):\n        if not np.isfinite(value):\n            raise ValueError(f\"Non-finite value at position {i}: {value}\")\n        \n        if abs(value) > 1e6:\n            raise ValueError(f\"Value too large at position {i}: {value}\")\n"