#!/usr/bin/env python3\n\"\"\"\nQuantum Collapse Kit - FastAPI Backend\n======================================\n\nPython FastAPI microservice for quantum tiebreaker operations\nwith Xanadu Cloud hardware acceleration.\n\"\"\"\n\nimport os\nimport logging\nfrom typing import List, Optional, Dict, Any\nfrom contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI, HTTPException, Depends, BackgroundTasks, Request\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.middleware.trustedhost import TrustedHostMiddleware\nfrom fastapi.responses import JSONResponse\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom pydantic import BaseModel, Field, validator\nimport uvicorn\n\n# Import our quantum services\nfrom services.quantum_service import QuantumService\nfrom services.hardware_service import HardwareService\nfrom models.quantum_models import (\n    CollapseRequest,\n    CollapseResponse,\n    HardwareStatusResponse,\n    DeviceTestRequest,\n    DeviceTestResponse,\n    HealthResponse\n)\nfrom routes import quantum_router, serendipity_router\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n# Initialize services\nquantum_service = QuantumService()\nhardware_service = HardwareService()\nsecurity = HTTPBearer(auto_error=False)\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Application lifespan manager\"\"\"\n    # Startup\n    logger.info(\"ðŸš€ Starting Quantum Collapse Kit Backend\")\n    \n    # Initialize quantum hardware\n    try:\n        await hardware_service.initialize()\n        logger.info(\"âœ… Quantum hardware initialized\")\n    except Exception as e:\n        logger.warning(f\"âš ï¸  Hardware initialization failed: {e}\")\n    \n    # Test quantum service\n    try:\n        health = await quantum_service.health_check()\n        if health:\n            logger.info(\"âœ… Quantum service operational\")\n        else:\n            logger.warning(\"âš ï¸  Quantum service degraded\")\n    except Exception as e:\n        logger.error(f\"âŒ Quantum service failed: {e}\")\n    \n    yield\n    \n    # Shutdown\n    logger.info(\"ðŸ›‘ Shutting down Quantum Collapse Kit Backend\")\n    await hardware_service.cleanup()\n\n\n# Create FastAPI app\napp = FastAPI(\n    title=\"Quantum Collapse Kit\",\n    description=\"FastAPI backend for quantum tiebreaker operations with Xanadu Cloud integration\",\n    version=\"1.0.0\",\n    docs_url=\"/docs\",\n    redoc_url=\"/redoc\",\n    lifespan=lifespan\n)\n\n# Add middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\n        \"http://localhost:3000\",\n        \"http://localhost:3001\", \n        \"https://*.vercel.app\",\n        os.getenv(\"FRONTEND_URL\", \"\")\n    ],\n    allow_credentials=True,\n    allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"],\n    allow_headers=[\"*\"],\n)\n\napp.add_middleware(\n    TrustedHostMiddleware,\n    allowed_hosts=[\n        \"localhost\",\n        \"127.0.0.1\",\n        \"*.herokuapp.com\",\n        \"*.vercel.app\",\n        os.getenv(\"ALLOWED_HOST\", \"*\")\n    ]\n)\n\n\n# Authentication dependency\nasync def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    \"\"\"Validate API token if authentication is enabled\"\"\"\n    if not os.getenv(\"REQUIRE_AUTH\", \"false\").lower() == \"true\":\n        return {\"authenticated\": False}\n    \n    if not credentials:\n        raise HTTPException(status_code=401, detail=\"Authentication required\")\n    \n    expected_token = os.getenv(\"QUANTUM_API_TOKEN\")\n    if not expected_token or credentials.credentials != expected_token:\n        raise HTTPException(status_code=401, detail=\"Invalid authentication token\")\n    \n    return {\"authenticated\": True, \"token\": credentials.credentials}\n\n\n# Include quantum routes\napp.include_router(\n    quantum_router.router,\n    prefix=\"/api/quantum\",\n    tags=[\"quantum\"],\n    dependencies=[Depends(get_current_user)]\n)\n\n\n# Root endpoints\n@app.get(\"/\")\nasync def root():\n    \"\"\"Root endpoint with service information\"\"\"\n    return {\n        \"service\": \"Quantum Collapse Kit Backend\",\n        \"version\": \"1.0.0\",\n        \"status\": \"operational\",\n        \"endpoints\": {\n            \"collapse\": \"/api/quantum/collapse\",\n            \"hardware\": \"/api/quantum/hardware/status\",\n            \"health\": \"/health\",\n            \"docs\": \"/docs\"\n        }\n    }\n\n\n@app.get(\"/health\", response_model=HealthResponse)\nasync def health_check():\n    \"\"\"Health check endpoint\"\"\"\n    try:\n        # Check quantum service\n        quantum_healthy = await quantum_service.health_check()\n        \n        # Check hardware service  \n        hardware_status = await hardware_service.get_status()\n        hardware_healthy = hardware_status.get(\"status\") == \"operational\"\n        \n        # Determine overall health\n        overall_healthy = quantum_healthy and hardware_healthy\n        \n        return HealthResponse(\n            status=\"healthy\" if overall_healthy else \"degraded\",\n            services={\n                \"quantum\": quantum_healthy,\n                \"hardware\": hardware_healthy,\n                \"database\": True  # No database in this service\n            },\n            version=\"1.0.0\",\n            timestamp=quantum_service._get_timestamp()\n        )\n        \n    except Exception as e:\n        logger.error(f\"Health check failed: {e}\")\n        return HealthResponse(\n            status=\"unhealthy\",\n            services={\"quantum\": False, \"hardware\": False, \"database\": False},\n            version=\"1.0.0\", \n            timestamp=quantum_service._get_timestamp(),\n            error=str(e)\n        )\n\n\n@app.get(\"/metrics\")\nasync def get_metrics():\n    \"\"\"Application metrics endpoint\"\"\"\n    try:\n        hardware_status = await hardware_service.get_status()\n        \n        return {\n            \"quantum_service\": {\n                \"total_requests\": getattr(quantum_service, '_request_count', 0),\n                \"successful_collapses\": getattr(quantum_service, '_success_count', 0),\n                \"hardware_executions\": getattr(quantum_service, '_hardware_count', 0),\n                \"average_processing_time\": getattr(quantum_service, '_avg_time', 0)\n            },\n            \"hardware_service\": {\n                \"available\": hardware_status.get(\"hardware_available\", False),\n                \"device\": hardware_status.get(\"device\", \"unknown\"),\n                \"last_check\": hardware_status.get(\"last_check\", \"never\")\n            },\n            \"system\": {\n                \"uptime\": getattr(app.state, 'uptime', 0),\n                \"memory_usage\": self._get_memory_usage(),\n                \"timestamp\": quantum_service._get_timestamp()\n            }\n        }\n        \n    except Exception as e:\n        logger.error(f\"Metrics collection failed: {e}\")\n        raise HTTPException(status_code=500, detail=\"Metrics unavailable\")\n\n\n# Error handlers\n@app.exception_handler(HTTPException)\nasync def http_exception_handler(request: Request, exc: HTTPException):\n    \"\"\"Handle HTTP exceptions with structured error response\"\"\"\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\n            \"error\": exc.detail,\n            \"status_code\": exc.status_code,\n            \"timestamp\": quantum_service._get_timestamp(),\n            \"path\": str(request.url)\n        }\n    )\n\n\n@app.exception_handler(Exception)\nasync def general_exception_handler(request: Request, exc: Exception):\n    \"\"\"Handle unexpected exceptions\"\"\"\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    \n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": str(exc) if app.debug else \"An unexpected error occurred\",\n            \"timestamp\": quantum_service._get_timestamp(),\n            \"path\": str(request.url)\n        }\n    )\n\n\ndef _get_memory_usage() -> dict:\n    \"\"\"Get current memory usage statistics\"\"\"\n    try:\n        import psutil\n        process = psutil.Process()\n        memory_info = process.memory_info()\n        \n        return {\n            \"rss\": memory_info.rss,\n            \"vms\": memory_info.vms,\n            \"percent\": process.memory_percent()\n        }\n    except ImportError:\n        return {\"rss\": 0, \"vms\": 0, \"percent\": 0}\n\n\nif __name__ == \"__main__\":\n    # Configuration\n    host = os.getenv(\"HOST\", \"0.0.0.0\")\n    port = int(os.getenv(\"PORT\", \"8000\"))\n    debug = os.getenv(\"DEBUG\", \"false\").lower() == \"true\"\n    workers = int(os.getenv(\"WORKERS\", \"1\"))\n    \n    logger.info(f\"ðŸš€ Starting server on {host}:{port}\")\n    logger.info(f\"ðŸ“Š Debug mode: {debug}\")\n    logger.info(f\"ðŸ‘¥ Workers: {workers}\")\n    \n    # Run server\n    uvicorn.run(\n        \"main:app\",\n        host=host,\n        port=port,\n        debug=debug,\n        reload=debug,\n        workers=workers if not debug else 1,\n        access_log=True,\n        log_level=\"info\" if not debug else \"debug\"\n    )\n"