#!/usr/bin/env python3\n\"\"\"\nHardware Service - Quantum hardware management\n==============================================\n\nManages connections to Xanadu Cloud quantum hardware.\n\"\"\"\n\nimport os\nimport sys\nimport logging\nimport asyncio\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime, timedelta\n\n# Add engine directory to path\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..', 'engine'))\n\ntry:\n    from quantum_hardware import (\n        check_hardware_availability,\n        validate_circuit_constraints,\n        hardware_quantum_kernel\n    )\n    from hardware.xanadu_factory import xanadu_factory\n    HARDWARE_MODULES_AVAILABLE = True\nexcept ImportError as e:\n    logging.warning(f\"Hardware modules not available: {e}\")\n    HARDWARE_MODULES_AVAILABLE = False\n\nlogger = logging.getLogger(__name__)\n\n\nclass HardwareService:\n    \"\"\"Service for managing quantum hardware connections\"\"\"\n    \n    def __init__(self):\n        self.last_status_check: Optional[datetime] = None\n        self.cached_status: Optional[Dict[str, Any]] = None\n        self.cache_timeout = timedelta(seconds=30)\n        self.connection_timeout = int(os.getenv(\"HARDWARE_TIMEOUT\", \"30\"))\n        \n        # Hardware configuration\n        self.api_key = os.getenv(\"SF_API_KEY\") or os.getenv(\"XANADU_API_KEY\")\n        self.default_device = os.getenv(\"XANADU_DEVICE\", \"X8\")\n        self.max_shots = int(os.getenv(\"XANADU_MAX_SHOTS\", \"1000\"))\n        self.hardware_enabled = os.getenv(\"XANADU_USE_HARDWARE\", \"true\").lower() == \"true\"\n        \n        logger.info(\"🔧 Hardware Service initialized\")\n    \n    async def initialize(self) -> None:\n        \"\"\"Initialize hardware service\"\"\"\n        logger.info(\"🔄 Initializing hardware connections...\")\n        \n        if not HARDWARE_MODULES_AVAILABLE:\n            logger.warning(\"⚠️  Hardware modules not available - using simulation mode\")\n            return\n        \n        try:\n            # Check initial hardware status\n            status = await self.get_status()\n            \n            if status.get(\"hardware_available\", False):\n                logger.info(f\"✅ Hardware initialized: {status.get('device', 'unknown')}\")\n            else:\n                logger.info(\"ℹ️  Hardware not available - simulation mode active\")\n                \n        except Exception as e:\n            logger.warning(f\"⚠️  Hardware initialization failed: {e}\")\n    \n    async def get_status(self) -> Dict[str, Any]:\n        \"\"\"Get current hardware status with caching\"\"\"\n        now = datetime.utcnow()\n        \n        # Return cached status if still valid\n        if (self.cached_status and \n            self.last_status_check and \n            now - self.last_status_check < self.cache_timeout):\n            return self.cached_status\n        \n        logger.debug(\"🔍 Checking hardware status...\")\n        \n        try:\n            if HARDWARE_MODULES_AVAILABLE:\n                # Use quantum hardware module\n                hardware_status = check_hardware_availability()\n                \n                self.cached_status = {\n                    \"status\": \"operational\",\n                    \"hardware_available\": hardware_status.get(\"hardware_available\", False),\n                    \"device\": hardware_status.get(\"device\", self.default_device),\n                    \"authenticated\": hardware_status.get(\"authenticated\", False),\n                    \"api_key_set\": hardware_status.get(\"api_key_set\", bool(self.api_key)),\n                    \"max_shots\": self.max_shots,\n                    \"max_wires\": 8,\n                    \"devices\": self._get_available_devices(hardware_status),\n                    \"last_check\": now.isoformat() + \"Z\",\n                    \"modules_available\": True\n                }\n            else:\n                # Fallback status when modules unavailable\n                self.cached_status = {\n                    \"status\": \"simulation_only\",\n                    \"hardware_available\": False,\n                    \"device\": \"local_simulator\",\n                    \"authenticated\": False,\n                    \"api_key_set\": bool(self.api_key),\n                    \"max_shots\": 1000,\n                    \"max_wires\": 16,\n                    \"devices\": [\n                        {\n                            \"name\": \"local_simulator\",\n                            \"type\": \"simulator\",\n                            \"wires\": 16,\n                            \"available\": True,\n                            \"queue_size\": 0\n                        }\n                    ],\n                    \"last_check\": now.isoformat() + \"Z\",\n                    \"modules_available\": False\n                }\n                \n        except Exception as e:\n            logger.error(f\"❌ Status check failed: {e}\")\n            \n            self.cached_status = {\n                \"status\": \"error\", \n                \"hardware_available\": False,\n                \"device\": \"unknown\",\n                \"authenticated\": False,\n                \"api_key_set\": bool(self.api_key),\n                \"max_shots\": 0,\n                \"max_wires\": 0,\n                \"devices\": [],\n                \"last_check\": now.isoformat() + \"Z\",\n                \"error\": str(e),\n                \"modules_available\": HARDWARE_MODULES_AVAILABLE\n            }\n        \n        self.last_status_check = now\n        return self.cached_status\n    \n    def _get_available_devices(self, hardware_status: Dict[str, Any]) -> List[Dict[str, Any]]:\n        \"\"\"Get list of available quantum devices\"\"\"\n        devices = []\n        \n        if hardware_status.get(\"hardware_available\", False):\n            # Add real hardware devices\n            devices.append({\n                \"name\": hardware_status.get(\"device\", \"X8\"),\n                \"type\": \"photonic\",\n                \"wires\": 8,\n                \"available\": True,\n                \"queue_size\": 0,\n                \"specifications\": {\n                    \"cutoff_dim\": 8,\n                    \"max_shots\": self.max_shots,\n                    \"connectivity\": \"all-to-all\",\n                    \"error_rate\": 0.001\n                }\n            })\n        \n        # Always add simulator options\n        devices.extend([\n            {\n                \"name\": \"local_simulator\",\n                \"type\": \"simulator\",\n                \"wires\": 16,\n                \"available\": True,\n                \"queue_size\": 0,\n                \"specifications\": {\n                    \"cutoff_dim\": 10,\n                    \"max_shots\": 100000,\n                    \"connectivity\": \"all-to-all\",\n                    \"error_rate\": 0.0\n                }\n            },\n            {\n                \"name\": \"fock_simulator\",\n                \"type\": \"simulator\",\n                \"wires\": 8,\n                \"available\": HARDWARE_MODULES_AVAILABLE,\n                \"queue_size\": 0,\n                \"specifications\": {\n                    \"cutoff_dim\": 5,\n                    \"max_shots\": 10000,\n                    \"connectivity\": \"photonic\",\n                    \"error_rate\": 0.0\n                }\n            }\n        ])\n        \n        return devices\n    \n    async def test_device_connection(\n        self,\n        device_name: Optional[str] = None\n    ) -> Dict[str, Any]:\n        \"\"\"Test connection to a specific quantum device\"\"\"\n        device = device_name or self.default_device\n        \n        logger.info(f\"🧪 Testing connection to device: {device}\")\n        \n        try:\n            if not HARDWARE_MODULES_AVAILABLE:\n                return {\n                    \"success\": device == \"local_simulator\",\n                    \"device\": device,\n                    \"latency\": 1,\n                    \"message\": \"Hardware modules not available\" if device != \"local_simulator\" else \"Simulator available\"\n                }\n            \n            import time\n            start_time = time.time()\n            \n            # Test quantum kernel computation\n            test_x = [0.5, 0.3]\n            test_y = [0.6, 0.4]\n            \n            kernel_value = hardware_quantum_kernel(\n                test_x,\n                test_y,\n                use_hardware=(device != \"local_simulator\")\n            )\n            \n            latency = (time.time() - start_time) * 1000  # Convert to ms\n            \n            success = isinstance(kernel_value, (int, float)) and 0 <= kernel_value <= 1\n            \n            return {\n                \"success\": success,\n                \"device\": device,\n                \"latency\": latency,\n                \"test_result\": kernel_value,\n                \"message\": \"Connection successful\" if success else \"Connection test failed\"\n            }\n            \n        except Exception as e:\n            logger.error(f\"❌ Device test failed for {device}: {e}\")\n            \n            return {\n                \"success\": False,\n                \"device\": device,\n                \"latency\": self.connection_timeout * 1000,\n                \"error\": str(e),\n                \"message\": f\"Connection failed: {e}\"\n            }\n    \n    async def validate_parameters(\n        self,\n        wires: int,\n        shots: int,\n        device: Optional[str] = None\n    ) -> Dict[str, Any]:\n        \"\"\"Validate circuit parameters for hardware constraints\"\"\"\n        \n        if not HARDWARE_MODULES_AVAILABLE:\n            return {\n                \"valid\": True,\n                \"adjusted_wires\": min(wires, 16),\n                \"adjusted_shots\": shots,\n                \"warnings\": [\"Hardware modules unavailable - using simulation limits\"]\n            }\n        \n        try:\n            adjusted_wires, adjusted_cutoff, adjusted_shots = validate_circuit_constraints(\n                wires, 5, shots\n            )\n            \n            warnings = []\n            if adjusted_wires != wires:\n                warnings.append(f\"Wires adjusted from {wires} to {adjusted_wires}\")\n            if adjusted_shots != shots:\n                warnings.append(f\"Shots adjusted from {shots} to {adjusted_shots}\")\n            \n            return {\n                \"valid\": True,\n                \"adjusted_wires\": adjusted_wires,\n                \"adjusted_shots\": adjusted_shots,\n                \"adjusted_cutoff\": adjusted_cutoff,\n                \"warnings\": warnings\n            }\n            \n        except Exception as e:\n            return {\n                \"valid\": False,\n                \"error\": str(e),\n                \"adjusted_wires\": wires,\n                \"adjusted_shots\": shots\n            }\n    \n    async def get_recommended_device(\n        self,\n        wires: int,\n        shots: int\n    ) -> str:\n        \"\"\"Get recommended device for given parameters\"\"\"\n        status = await self.get_status()\n        \n        # If hardware available and parameters within limits\n        if (status.get(\"hardware_available\", False) and \n            wires <= 8 and \n            shots <= self.max_shots):\n            return status.get(\"device\", \"X8\")\n        \n        # Fallback recommendations\n        if wires <= 8 and HARDWARE_MODULES_AVAILABLE:\n            return \"fock_simulator\"\n        \n        return \"local_simulator\"\n    \n    def clear_cache(self) -> None:\n        \"\"\"Clear cached hardware status\"\"\"\n        self.cached_status = None\n        self.last_status_check = None\n        logger.debug(\"🗑️  Hardware status cache cleared\")\n    \n    async def cleanup(self) -> None:\n        \"\"\"Cleanup hardware resources\"\"\"\n        logger.info(\"🧹 Cleaning up hardware resources...\")\n        \n        try:\n            # Clear cache\n            self.clear_cache()\n            \n            # Close any open connections\n            if HARDWARE_MODULES_AVAILABLE:\n                # Add specific cleanup if needed\n                pass\n                \n            logger.info(\"✅ Hardware cleanup completed\")\n            \n        except Exception as e:\n            logger.error(f\"❌ Hardware cleanup failed: {e}\")\n"