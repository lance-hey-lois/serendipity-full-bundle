#!/usr/bin/env python3\n\"\"\"\nQuantum Collapse Kit - System Validation Script\n===============================================\n\nComprehensive validation script that tests the complete\nsystem integration and validates quantum tiebreaker functionality.\n\"\"\"\n\nimport asyncio\nimport json\nimport logging\nimport os\nimport sys\nimport time\nfrom typing import Dict, List, Any, Optional\nimport traceback\n\nimport aiohttp\nimport numpy as np\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n# Configuration\nBACKEND_URL = os.getenv('QUANTUM_BACKEND_URL', 'http://localhost:8000')\nFRONTEND_URL = os.getenv('FRONTEND_URL', 'http://localhost:3000')\nAPI_TOKEN = os.getenv('QUANTUM_API_TOKEN', '')\nTEST_TIMEOUT = 30  # seconds\n\nclass QuantumValidator:\n    \"\"\"Validates the Quantum Collapse Kit system\"\"\"\n    \n    def __init__(self):\n        self.session: Optional[aiohttp.ClientSession] = None\n        self.results = {\n            'timestamp': datetime.utcnow().isoformat() + 'Z',\n            'backend_tests': {},\n            'frontend_tests': {},\n            'integration_tests': {},\n            'hardware_tests': {},\n            'performance_tests': {},\n            'overall_status': 'unknown'\n        }\n        self.headers = {\n            'Content-Type': 'application/json'\n        }\n        \n        if API_TOKEN:\n            self.headers['Authorization'] = f'Bearer {API_TOKEN}'\n    \n    async def __aenter__(self):\n        \"\"\"Async context manager entry\"\"\"\n        timeout = aiohttp.ClientTimeout(total=TEST_TIMEOUT)\n        self.session = aiohttp.ClientSession(timeout=timeout, headers=self.headers)\n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit\"\"\"\n        if self.session:\n            await self.session.close()\n    \n    async def validate_backend_health(self) -> Dict[str, Any]:\n        \"\"\"Validate backend service health\"\"\"\n        logger.info(\"ğŸ” Validating backend health...\")\n        \n        test_results = {}\n        \n        try:\n            # Health check endpoint\n            async with self.session.get(f'{BACKEND_URL}/health') as response:\n                if response.status == 200:\n                    health_data = await response.json()\n                    test_results['health_endpoint'] = {\n                        'status': 'pass',\n                        'response': health_data\n                    }\n                    logger.info(f\"âœ… Backend health: {health_data.get('status', 'unknown')}\")\n                else:\n                    test_results['health_endpoint'] = {\n                        'status': 'fail',\n                        'error': f'HTTP {response.status}'\n                    }\n        except Exception as e:\n            test_results['health_endpoint'] = {\n                'status': 'fail',\n                'error': str(e)\n            }\n            logger.error(f\"âŒ Backend health check failed: {e}\")\n        \n        # API documentation endpoint\n        try:\n            async with self.session.get(f'{BACKEND_URL}/docs') as response:\n                if response.status == 200:\n                    test_results['docs_endpoint'] = {'status': 'pass'}\n                    logger.info(\"âœ… API documentation accessible\")\n                else:\n                    test_results['docs_endpoint'] = {\n                        'status': 'fail',\n                        'error': f'HTTP {response.status}'\n                    }\n        except Exception as e:\n            test_results['docs_endpoint'] = {'status': 'fail', 'error': str(e)}\n        \n        # Metrics endpoint\n        try:\n            async with self.session.get(f'{BACKEND_URL}/metrics') as response:\n                if response.status == 200:\n                    metrics_data = await response.json()\n                    test_results['metrics_endpoint'] = {\n                        'status': 'pass',\n                        'response': metrics_data\n                    }\n                    logger.info(\"âœ… Metrics endpoint accessible\")\n                else:\n                    test_results['metrics_endpoint'] = {\n                        'status': 'fail',\n                        'error': f'HTTP {response.status}'\n                    }\n        except Exception as e:\n            test_results['metrics_endpoint'] = {'status': 'fail', 'error': str(e)}\n        \n        return test_results\n    \n    async def validate_hardware_status(self) -> Dict[str, Any]:\n        \"\"\"Validate quantum hardware status\"\"\"\n        logger.info(\"ğŸ”§ Validating hardware status...\")\n        \n        test_results = {}\n        \n        try:\n            async with self.session.get(f'{BACKEND_URL}/api/quantum/hardware/status') as response:\n                if response.status == 200:\n                    hardware_data = await response.json()\n                    test_results['hardware_status'] = {\n                        'status': 'pass',\n                        'hardware_available': hardware_data.get('hardware_available', False),\n                        'device': hardware_data.get('device', 'unknown'),\n                        'authenticated': hardware_data.get('authenticated', False)\n                    }\n                    \n                    if hardware_data.get('hardware_available'):\n                        logger.info(f\"âœ… Quantum hardware available: {hardware_data.get('device')}\")\n                    else:\n                        logger.info(\"â„¹ï¸  Quantum hardware not available - using simulation\")\n                else:\n                    test_results['hardware_status'] = {\n                        'status': 'fail',\n                        'error': f'HTTP {response.status}'\n                    }\n        except Exception as e:\n            test_results['hardware_status'] = {'status': 'fail', 'error': str(e)}\n        \n        # Test device connection\n        try:\n            test_data = {\n                'device': 'local_simulator',\n                'test_shots': 10,\n                'timeout': 10\n            }\n            \n            async with self.session.post(\n                f'{BACKEND_URL}/api/quantum/hardware/test',\n                json=test_data\n            ) as response:\n                if response.status == 200:\n                    connection_data = await response.json()\n                    test_results['device_test'] = {\n                        'status': 'pass',\n                        'success': connection_data.get('success', False),\n                        'latency': connection_data.get('latency', 0)\n                    }\n                    logger.info(f\"âœ… Device test successful: {connection_data.get('latency', 0):.1f}ms\")\n                else:\n                    test_results['device_test'] = {\n                        'status': 'fail',\n                        'error': f'HTTP {response.status}'\n                    }\n        except Exception as e:\n            test_results['device_test'] = {'status': 'fail', 'error': str(e)}\n        \n        return test_results\n    \n    async def validate_quantum_collapse(self) -> Dict[str, Any]:\n        \"\"\"Validate quantum collapse functionality\"\"\"\n        logger.info(\"âš›ï¸  Validating quantum collapse...\")\n        \n        test_results = {}\n        \n        # Test cases with different scenarios\n        test_cases = [\n            {\n                'name': 'basic_collapse',\n                'seed_vector': [0.5, 0.5],\n                'candidate_vectors': [[0.6, 0.4], [0.4, 0.6]],\n                'use_hardware': False\n            },\n            {\n                'name': 'multi_candidate_collapse',\n                'seed_vector': [0.5, 0.3, 0.8],\n                'candidate_vectors': [\n                    [0.6, 0.2, 0.7],\n                    [0.4, 0.5, 0.6],\n                    [0.3, 0.4, 0.5],\n                    [0.7, 0.1, 0.9]\n                ],\n                'use_hardware': False,\n                'max_shots': 100\n            },\n            {\n                'name': 'large_vector_collapse',\n                'seed_vector': np.random.rand(50).tolist(),\n                'candidate_vectors': [np.random.rand(50).tolist() for _ in range(5)],\n                'use_hardware': False\n            }\n        ]\n        \n        for test_case in test_cases:\n            try:\n                start_time = time.time()\n                \n                async with self.session.post(\n                    f'{BACKEND_URL}/api/quantum/collapse',\n                    json=test_case\n                ) as response:\n                    processing_time = (time.time() - start_time) * 1000\n                    \n                    if response.status == 200:\n                        result_data = await response.json()\n                        \n                        # Validate response structure\n                        is_valid = all([\n                            result_data.get('success') is True,\n                            isinstance(result_data.get('selected_index'), int),\n                            0 <= result_data.get('selected_index') < len(test_case['candidate_vectors']),\n                            isinstance(result_data.get('confidence'), (int, float)),\n                            0.0 <= result_data.get('confidence') <= 1.0,\n                            isinstance(result_data.get('quantum_kernel'), list),\n                            len(result_data.get('quantum_kernel', [])) == len(test_case['candidate_vectors'])\n                        ])\n                        \n                        test_results[test_case['name']] = {\n                            'status': 'pass' if is_valid else 'fail',\n                            'selected_index': result_data.get('selected_index'),\n                            'confidence': result_data.get('confidence'),\n                            'processing_time': processing_time,\n                            'hardware_used': result_data.get('hardware_used', False),\n                            'validation_passed': is_valid\n                        }\n                        \n                        if is_valid:\n                            logger.info(f\"âœ… {test_case['name']}: Index {result_data.get('selected_index')}, Confidence {result_data.get('confidence'):.3f}\")\n                        else:\n                            logger.error(f\"âŒ {test_case['name']}: Response validation failed\")\n                    else:\n                        error_data = await response.text()\n                        test_results[test_case['name']] = {\n                            'status': 'fail',\n                            'error': f'HTTP {response.status}: {error_data}'\n                        }\n            except Exception as e:\n                test_results[test_case['name']] = {\n                    'status': 'fail',\n                    'error': str(e)\n                }\n                logger.error(f\"âŒ {test_case['name']} failed: {e}\")\n        \n        return test_results\n    \n    async def validate_frontend_integration(self) -> Dict[str, Any]:\n        \"\"\"Validate frontend integration\"\"\"\n        logger.info(\"ğŸŒ Validating frontend integration...\")\n        \n        test_results = {}\n        \n        # Test frontend health endpoint\n        try:\n            async with self.session.get(f'{FRONTEND_URL}/api/quantum/health') as response:\n                if response.status == 200:\n                    health_data = await response.json()\n                    test_results['frontend_health'] = {\n                        'status': 'pass',\n                        'response': health_data\n                    }\n                    logger.info(\"âœ… Frontend health endpoint accessible\")\n                else:\n                    test_results['frontend_health'] = {\n                        'status': 'fail',\n                        'error': f'HTTP {response.status}'\n                    }\n        except Exception as e:\n            test_results['frontend_health'] = {'status': 'fail', 'error': str(e)}\n            logger.warning(f\"âš ï¸  Frontend health check failed: {e}\")\n        \n        # Test frontend quantum collapse endpoint\n        try:\n            test_data = {\n                'seedVector': [0.5, 0.5],\n                'candidateVectors': [[0.6, 0.4], [0.4, 0.6]],\n                'useHardware': False\n            }\n            \n            async with self.session.post(\n                f'{FRONTEND_URL}/api/quantum/collapse',\n                json=test_data\n            ) as response:\n                if response.status == 200:\n                    result_data = await response.json()\n                    test_results['frontend_collapse'] = {\n                        'status': 'pass',\n                        'result': result_data\n                    }\n                    logger.info(\"âœ… Frontend quantum collapse endpoint working\")\n                else:\n                    test_results['frontend_collapse'] = {\n                        'status': 'fail',\n                        'error': f'HTTP {response.status}'\n                    }\n        except Exception as e:\n            test_results['frontend_collapse'] = {'status': 'fail', 'error': str(e)}\n            logger.warning(f\"âš ï¸  Frontend collapse test failed: {e}\")\n        \n        return test_results\n    \n    async def validate_performance(self) -> Dict[str, Any]:\n        \"\"\"Validate system performance\"\"\"\n        logger.info(\"âš¡ Validating performance...\")\n        \n        test_results = {}\n        \n        # Performance test with multiple concurrent requests\n        try:\n            test_data = {\n                'seed_vector': [0.5, 0.5],\n                'candidate_vectors': [[0.6, 0.4], [0.4, 0.6], [0.5, 0.5]],\n                'use_hardware': False\n            }\n            \n            num_requests = 5\n            start_time = time.time()\n            \n            # Create concurrent requests\n            tasks = []\n            for _ in range(num_requests):\n                task = self.session.post(\n                    f'{BACKEND_URL}/api/quantum/collapse',\n                    json=test_data\n                )\n                tasks.append(task)\n            \n            # Execute all requests concurrently\n            responses = await asyncio.gather(*tasks, return_exceptions=True)\n            total_time = (time.time() - start_time) * 1000\n            \n            # Process responses\n            successful_requests = 0\n            failed_requests = 0\n            \n            for response in responses:\n                if isinstance(response, Exception):\n                    failed_requests += 1\n                else:\n                    if response.status == 200:\n                        successful_requests += 1\n                    else:\n                        failed_requests += 1\n                    response.close()\n            \n            test_results['concurrent_requests'] = {\n                'status': 'pass' if failed_requests == 0 else 'partial',\n                'total_requests': num_requests,\n                'successful_requests': successful_requests,\n                'failed_requests': failed_requests,\n                'total_time': total_time,\n                'average_time_per_request': total_time / num_requests\n            }\n            \n            if failed_requests == 0:\n                logger.info(f\"âœ… Performance test: {num_requests} requests in {total_time:.1f}ms\")\n            else:\n                logger.warning(f\"âš ï¸  Performance test: {failed_requests}/{num_requests} requests failed\")\n        \n        except Exception as e:\n            test_results['concurrent_requests'] = {'status': 'fail', 'error': str(e)}\n            logger.error(f\"âŒ Performance test failed: {e}\")\n        \n        return test_results\n    \n    async def validate_batch_processing(self) -> Dict[str, Any]:\n        \"\"\"Validate batch processing functionality\"\"\"\n        logger.info(\"ğŸ“¦ Validating batch processing...\")\n        \n        test_results = {}\n        \n        try:\n            batch_data = {\n                'requests': [\n                    {\n                        'seed_vector': [0.5, 0.5],\n                        'candidate_vectors': [[0.6, 0.4], [0.4, 0.6]],\n                        'use_hardware': False\n                    },\n                    {\n                        'seed_vector': [0.3, 0.7],\n                        'candidate_vectors': [[0.8, 0.2], [0.2, 0.8], [0.5, 0.5]],\n                        'use_hardware': False\n                    }\n                ],\n                'parallel_execution': True,\n                'max_concurrency': 2\n            }\n            \n            async with self.session.post(\n                f'{BACKEND_URL}/api/quantum/batch_collapse',\n                json=batch_data\n            ) as response:\n                if response.status == 200:\n                    result_data = await response.json()\n                    \n                    is_valid = all([\n                        result_data.get('success') is True,\n                        result_data.get('success_count') == 2,\n                        result_data.get('failure_count') == 0,\n                        len(result_data.get('results', [])) == 2\n                    ])\n                    \n                    test_results['batch_collapse'] = {\n                        'status': 'pass' if is_valid else 'fail',\n                        'success_count': result_data.get('success_count'),\n                        'failure_count': result_data.get('failure_count'),\n                        'processing_time': result_data.get('total_processing_time'),\n                        'validation_passed': is_valid\n                    }\n                    \n                    if is_valid:\n                        logger.info(f\"âœ… Batch processing: {result_data.get('success_count')} successful\")\n                    else:\n                        logger.error(\"âŒ Batch processing validation failed\")\n                else:\n                    error_data = await response.text()\n                    test_results['batch_collapse'] = {\n                        'status': 'fail',\n                        'error': f'HTTP {response.status}: {error_data}'\n                    }\n        except Exception as e:\n            test_results['batch_collapse'] = {'status': 'fail', 'error': str(e)}\n            logger.error(f\"âŒ Batch processing failed: {e}\")\n        \n        return test_results\n    \n    async def run_all_validations(self) -> Dict[str, Any]:\n        \"\"\"Run all validation tests\"\"\"\n        logger.info(\"ğŸš€ Starting comprehensive system validation...\")\n        \n        try:\n            # Backend validation\n            self.results['backend_tests'] = await self.validate_backend_health()\n            \n            # Hardware validation\n            self.results['hardware_tests'] = await self.validate_hardware_status()\n            \n            # Quantum collapse validation\n            self.results['integration_tests'] = await self.validate_quantum_collapse()\n            \n            # Frontend validation\n            self.results['frontend_tests'] = await self.validate_frontend_integration()\n            \n            # Performance validation\n            self.results['performance_tests'] = await self.validate_performance()\n            \n            # Batch processing validation\n            batch_results = await self.validate_batch_processing()\n            self.results['integration_tests'].update(batch_results)\n            \n        except Exception as e:\n            logger.error(f\"âŒ Validation failed with exception: {e}\")\n            traceback.print_exc()\n        \n        # Determine overall status\n        self.results['overall_status'] = self._calculate_overall_status()\n        \n        return self.results\n    \n    def _calculate_overall_status(self) -> str:\n        \"\"\"Calculate overall system status based on test results\"\"\"\n        total_tests = 0\n        passed_tests = 0\n        \n        for category, tests in self.results.items():\n            if category in ['timestamp', 'overall_status']:\n                continue\n            \n            if isinstance(tests, dict):\n                for test_name, test_result in tests.items():\n                    total_tests += 1\n                    if isinstance(test_result, dict) and test_result.get('status') == 'pass':\n                        passed_tests += 1\n        \n        if total_tests == 0:\n            return 'unknown'\n        \n        success_rate = passed_tests / total_tests\n        \n        if success_rate >= 0.9:\n            return 'healthy'\n        elif success_rate >= 0.7:\n            return 'degraded'\n        else:\n            return 'unhealthy'\n    \n    def print_summary(self):\n        \"\"\"Print validation summary\"\"\"\n        print(\"\\n\" + \"=\"*60)\n        print(\"ğŸ§ª QUANTUM COLLAPSE KIT VALIDATION SUMMARY\")\n        print(\"=\"*60)\n        \n        overall_status = self.results.get('overall_status', 'unknown')\n        status_emoji = {\n            'healthy': 'âœ…',\n            'degraded': 'âš ï¸',\n            'unhealthy': 'âŒ',\n            'unknown': 'â“'\n        }\n        \n        print(f\"\\nOverall Status: {status_emoji.get(overall_status, 'â“')} {overall_status.upper()}\")\n        print(f\"Validation Time: {self.results.get('timestamp', 'unknown')}\")\n        \n        # Print category summaries\n        categories = {\n            'backend_tests': 'Backend Service',\n            'hardware_tests': 'Quantum Hardware',\n            'integration_tests': 'Integration Tests',\n            'frontend_tests': 'Frontend Service',\n            'performance_tests': 'Performance Tests'\n        }\n        \n        for category, display_name in categories.items():\n            tests = self.results.get(category, {})\n            if tests:\n                passed = sum(1 for test in tests.values() \n                           if isinstance(test, dict) and test.get('status') == 'pass')\n                total = len(tests)\n                \n                status = 'âœ…' if passed == total else 'âš ï¸' if passed > 0 else 'âŒ'\n                print(f\"\\n{display_name}: {status} {passed}/{total} tests passed\")\n                \n                for test_name, test_result in tests.items():\n                    if isinstance(test_result, dict):\n                        test_status = test_result.get('status', 'unknown')\n                        test_emoji = 'âœ…' if test_status == 'pass' else 'âŒ'\n                        print(f\"  {test_emoji} {test_name}: {test_status}\")\n        \n        print(\"\\n\" + \"=\"*60)\n\n\nasync def main():\n    \"\"\"Main validation function\"\"\"\n    try:\n        async with QuantumValidator() as validator:\n            results = await validator.run_all_validations()\n            validator.print_summary()\n            \n            # Save results to file\n            output_file = f\"validation_results_{int(time.time())}.json\"\n            with open(output_file, 'w') as f:\n                json.dump(results, f, indent=2, default=str)\n            \n            logger.info(f\"ğŸ“„ Results saved to: {output_file}\")\n            \n            # Exit with appropriate code\n            overall_status = results.get('overall_status', 'unknown')\n            if overall_status == 'healthy':\n                sys.exit(0)\n            elif overall_status == 'degraded':\n                sys.exit(1)\n            else:\n                sys.exit(2)\n            \n    except KeyboardInterrupt:\n        logger.info(\"\\nğŸ›‘ Validation interrupted by user\")\n        sys.exit(130)\n    except Exception as e:\n        logger.error(f\"âŒ Validation failed: {e}\")\n        traceback.print_exc()\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    print(\"ğŸ§ª Quantum Collapse Kit System Validation\")\n    print(\"==========================================\\n\")\n    \n    asyncio.run(main())\n"