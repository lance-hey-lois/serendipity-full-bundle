#!/usr/bin/env python3\n\"\"\"\nQuantum Service - Core quantum collapse logic\n============================================\n\nImplements the quantum tiebreaker mechanism with Xanadu hardware integration.\n\"\"\"\n\nimport os\nimport sys\nimport logging\nimport time\nfrom typing import List, Dict, Any, Optional, Tuple\nfrom datetime import datetime\nimport asyncio\n\nimport numpy as np\n\n# Add the engine directory to Python path for imports\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..', 'engine'))\n\nfrom models.quantum_models import CollapseRequest, CollapseResponse\nfrom .hardware_service import HardwareService\n\n# Try to import quantum components\ntry:\n    from quantum import quantum_kernel_to_seed, zscore\n    from quantum_hardware import make_pl_device, check_hardware_availability\n    QUANTUM_AVAILABLE = True\nexcept ImportError as e:\n    logging.warning(f\"Quantum modules not available: {e}\")\n    QUANTUM_AVAILABLE = False\n\nlogger = logging.getLogger(__name__)\n\n\nclass QuantumService:\n    \"\"\"Service for quantum collapse operations\"\"\"\n    \n    def __init__(self):\n        self.hardware_service = HardwareService()\n        self._request_count = 0\n        self._success_count = 0\n        self._hardware_count = 0\n        self._total_time = 0\n        self._avg_time = 0\n        \n        # Configuration\n        self.max_retries = int(os.getenv(\"QUANTUM_MAX_RETRIES\", \"3\"))\n        self.timeout = int(os.getenv(\"QUANTUM_TIMEOUT\", \"30\"))\n        self.fallback_enabled = os.getenv(\"QUANTUM_FALLBACK\", \"true\").lower() == \"true\"\n        \n        logger.info(\"🔬 Quantum Service initialized\")\n        \n    async def perform_collapse(\n        self, \n        request: CollapseRequest\n    ) -> CollapseResponse:\n        \"\"\"Perform quantum collapse tiebreaker\"\"\"\n        start_time = time.time()\n        self._request_count += 1\n        \n        try:\n            logger.info(f\"🎯 Processing collapse request: {len(request.candidate_vectors)} candidates\")\n            \n            # Validate request\n            self._validate_collapse_request(request)\n            \n            # Prepare vectors\n            seed_vec = np.array(request.seed_vector, dtype=float)\n            cand_vecs = np.array(request.candidate_vectors, dtype=float)\n            \n            # Attempt quantum processing\n            result = await self._process_quantum_collapse(\n                seed_vec,\n                cand_vecs,\n                use_hardware=request.use_hardware,\n                max_shots=request.max_shots,\n                method=request.method\n            )\n            \n            # Update metrics\n            processing_time = (time.time() - start_time) * 1000\n            self._success_count += 1\n            self._total_time += processing_time\n            self._avg_time = self._total_time / self._success_count\n            \n            if result[\"hardware_used\"]:\n                self._hardware_count += 1\n            \n            logger.info(f\"✅ Collapse completed in {processing_time:.2f}ms\")\n            \n            return CollapseResponse(\n                success=True,\n                selected_index=result[\"selected_index\"],\n                confidence=result[\"confidence\"],\n                quantum_kernel=result[\"quantum_kernel\"],\n                hardware_used=result[\"hardware_used\"],\n                device=result[\"device\"],\n                shots=result[\"shots\"],\n                method=result[\"method\"],\n                processing_time=processing_time,\n                timestamp=self._get_timestamp()\n            )\n            \n        except Exception as e:\n            logger.error(f\"❌ Collapse failed: {e}\")\n            raise\n    \n    async def _process_quantum_collapse(\n        self,\n        seed_vec: np.ndarray,\n        cand_vecs: np.ndarray,\n        use_hardware: bool = True,\n        max_shots: int = 1000,\n        method: str = \"kernel_fidelity\"\n    ) -> Dict[str, Any]:\n        \"\"\"Process quantum collapse with hardware/simulation fallback\"\"\"\n        \n        hardware_used = False\n        device = \"local_simulator\"\n        shots = 0\n        \n        if QUANTUM_AVAILABLE and use_hardware:\n            try:\n                # Check hardware availability\n                hardware_status = await self.hardware_service.get_status()\n                \n                if hardware_status.get(\"hardware_available\", False):\n                    # Attempt hardware execution\n                    logger.info(\"🔧 Attempting quantum hardware execution\")\n                    \n                    kernel_values = quantum_kernel_to_seed(\n                        seed_vec,\n                        cand_vecs,\n                        use_hardware=True,\n                        max_shots=max_shots\n                    )\n                    \n                    hardware_used = True\n                    device = hardware_status.get(\"device\", \"X8\")\n                    shots = max_shots\n                    \n                    logger.info(f\"✅ Hardware execution successful on {device}\")\n                    \n                else:\n                    logger.info(\"⚠️  Hardware unavailable, using simulation\")\n                    raise Exception(\"Hardware not available\")\n                    \n            except Exception as e:\n                logger.warning(f\"Hardware execution failed: {e}\")\n                if not self.fallback_enabled:\n                    raise\n                \n                # Fallback to simulation\n                logger.info(\"🔄 Falling back to quantum simulation\")\n        \n        # Use simulation if hardware failed or not requested\n        if not hardware_used:\n            if QUANTUM_AVAILABLE:\n                kernel_values = quantum_kernel_to_seed(\n                    seed_vec,\n                    cand_vecs,\n                    use_hardware=False,\n                    max_shots=0\n                )\n            else:\n                # Ultimate fallback: classical similarity\n                logger.warning(\"🔄 Using classical similarity fallback\")\n                kernel_values = self._classical_similarity_fallback(seed_vec, cand_vecs)\n        \n        # Select winner and calculate confidence\n        selected_index = np.argmax(kernel_values)\n        confidence = self._calculate_confidence(kernel_values, selected_index)\n        \n        return {\n            \"selected_index\": int(selected_index),\n            \"confidence\": float(confidence),\n            \"quantum_kernel\": kernel_values.tolist(),\n            \"hardware_used\": hardware_used,\n            \"device\": device,\n            \"shots\": shots,\n            \"method\": method\n        }\n    \n    def _classical_similarity_fallback(\n        self,\n        seed_vec: np.ndarray,\n        cand_vecs: np.ndarray\n    ) -> np.ndarray:\n        \"\"\"Classical cosine similarity as ultimate fallback\"\"\"\n        similarities = []\n        \n        for cand_vec in cand_vecs:\n            # Cosine similarity\n            dot_product = np.dot(seed_vec, cand_vec)\n            norms = np.linalg.norm(seed_vec) * np.linalg.norm(cand_vec)\n            \n            if norms > 1e-10:\n                similarity = dot_product / norms\n            else:\n                similarity = 0.0\n                \n            # Add some quantum-inspired noise\n            quantum_noise = np.random.normal(0, 0.05)\n            similarity = max(0, min(1, similarity + quantum_noise))\n            \n            similarities.append(similarity)\n        \n        return np.array(similarities)\n    \n    def _calculate_confidence(\n        self,\n        kernel_values: np.ndarray,\n        selected_index: int\n    ) -> float:\n        \"\"\"Calculate confidence score for the selected option\"\"\"\n        if len(kernel_values) <= 1:\n            return 1.0\n        \n        selected_value = kernel_values[selected_index]\n        other_values = np.delete(kernel_values, selected_index)\n        max_other = np.max(other_values)\n        \n        # Relative confidence\n        if selected_value + max_other > 1e-10:\n            confidence = (selected_value - max_other) / (selected_value + max_other)\n        else:\n            confidence = 0.0\n            \n        return max(0.0, min(1.0, confidence))\n    \n    def _validate_collapse_request(self, request: CollapseRequest) -> None:\n        \"\"\"Validate collapse request parameters\"\"\"\n        if not request.seed_vector or len(request.seed_vector) == 0:\n            raise ValueError(\"Seed vector cannot be empty\")\n        \n        if not request.candidate_vectors or len(request.candidate_vectors) == 0:\n            raise ValueError(\"Candidate vectors cannot be empty\")\n        \n        seed_dim = len(request.seed_vector)\n        \n        for i, candidate in enumerate(request.candidate_vectors):\n            if len(candidate) != seed_dim:\n                raise ValueError(\n                    f\"Candidate vector {i} has dimension {len(candidate)}, \"\n                    f\"expected {seed_dim}\"\n                )\n        \n        # Check for valid numbers\n        all_values = request.seed_vector + [v for vec in request.candidate_vectors for v in vec]\n        \n        for i, value in enumerate(all_values):\n            if not np.isfinite(value):\n                raise ValueError(f\"Invalid value at position {i}: {value}\")\n        \n        # Parameter validation\n        if request.max_shots and (request.max_shots < 10 or request.max_shots > 10000):\n            raise ValueError(\"Max shots must be between 10 and 10000\")\n        \n        if request.method and request.method not in [\"kernel_fidelity\", \"amplitude_encoding\", \"angle_encoding\"]:\n            raise ValueError(f\"Invalid method: {request.method}\")\n    \n    async def health_check(self) -> bool:\n        \"\"\"Check if quantum service is operational\"\"\"\n        try:\n            # Simple test collapse\n            test_request = CollapseRequest(\n                seed_vector=[0.5, 0.5],\n                candidate_vectors=[[0.6, 0.4], [0.4, 0.6]],\n                use_hardware=False\n            )\n            \n            await self.perform_collapse(test_request)\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Health check failed: {e}\")\n            return False\n    \n    async def get_metrics(self) -> Dict[str, Any]:\n        \"\"\"Get service metrics\"\"\"\n        return {\n            \"total_requests\": self._request_count,\n            \"successful_collapses\": self._success_count,\n            \"hardware_executions\": self._hardware_count,\n            \"success_rate\": self._success_count / max(1, self._request_count),\n            \"hardware_usage_rate\": self._hardware_count / max(1, self._success_count),\n            \"average_processing_time\": self._avg_time,\n            \"quantum_available\": QUANTUM_AVAILABLE,\n            \"fallback_enabled\": self.fallback_enabled\n        }\n    \n    def _get_timestamp(self) -> str:\n        \"\"\"Get current timestamp in ISO format\"\"\"\n        return datetime.utcnow().isoformat() + \"Z\"\n"