#!/usr/bin/env python3\n\"\"\"\nTest suite for Quantum Service\n==============================\n\nComprehensive tests for the quantum collapse backend service.\n\"\"\"\n\nimport pytest\nimport numpy as np\nfrom unittest.mock import Mock, patch, AsyncMock\n\nimport sys\nimport os\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..', 'backend'))\n\nfrom models.quantum_models import CollapseRequest, CollapseResponse\nfrom services.quantum_service import QuantumService\nfrom services.hardware_service import HardwareService\n\n\nclass TestQuantumService:\n    \"\"\"Test cases for QuantumService\"\"\"\n    \n    @pytest.fixture\n    def quantum_service(self):\n        \"\"\"Create a quantum service instance for testing\"\"\"\n        return QuantumService()\n    \n    @pytest.fixture\n    def sample_collapse_request(self):\n        \"\"\"Sample collapse request for testing\"\"\"\n        return CollapseRequest(\n            seed_vector=[0.5, 0.5],\n            candidate_vectors=[[0.6, 0.4], [0.4, 0.6], [0.5, 0.5]],\n            use_hardware=False,\n            max_shots=100,\n            method=\"kernel_fidelity\"\n        )\n    \n    @pytest.mark.asyncio\n    async def test_perform_collapse_basic(self, quantum_service, sample_collapse_request):\n        \"\"\"Test basic quantum collapse functionality\"\"\"\n        result = await quantum_service.perform_collapse(sample_collapse_request)\n        \n        assert isinstance(result, CollapseResponse)\n        assert result.success is True\n        assert 0 <= result.selected_index < 3\n        assert 0.0 <= result.confidence <= 1.0\n        assert len(result.quantum_kernel) == 3\n        assert result.processing_time > 0\n    \n    @pytest.mark.asyncio\n    async def test_validate_collapse_request(self, quantum_service):\n        \"\"\"Test request validation\"\"\"\n        # Valid request should not raise\n        valid_request = CollapseRequest(\n            seed_vector=[0.5, 0.5],\n            candidate_vectors=[[0.6, 0.4]],\n            use_hardware=False\n        )\n        \n        # Should not raise exception\n        quantum_service._validate_collapse_request(valid_request)\n        \n        # Invalid request - empty seed vector\n        with pytest.raises(ValueError, match=\"Seed vector cannot be empty\"):\n            invalid_request = CollapseRequest(\n                seed_vector=[],\n                candidate_vectors=[[0.6, 0.4]],\n                use_hardware=False\n            )\n            quantum_service._validate_collapse_request(invalid_request)\n        \n        # Invalid request - dimension mismatch\n        with pytest.raises(ValueError, match=\"dimension\"):\n            invalid_request = CollapseRequest(\n                seed_vector=[0.5, 0.5],\n                candidate_vectors=[[0.6, 0.4, 0.2]],  # Wrong dimension\n                use_hardware=False\n            )\n            quantum_service._validate_collapse_request(invalid_request)\n        \n        # Invalid request - non-finite values\n        with pytest.raises(ValueError, match=\"Invalid value\"):\n            invalid_request = CollapseRequest(\n                seed_vector=[0.5, float('nan')],\n                candidate_vectors=[[0.6, 0.4]],\n                use_hardware=False\n            )\n            quantum_service._validate_collapse_request(invalid_request)\n    \n    def test_classical_similarity_fallback(self, quantum_service):\n        \"\"\"Test classical similarity fallback\"\"\"\n        seed_vec = np.array([0.5, 0.5])\n        cand_vecs = np.array([[0.6, 0.4], [0.4, 0.6]])\n        \n        similarities = quantum_service._classical_similarity_fallback(seed_vec, cand_vecs)\n        \n        assert isinstance(similarities, np.ndarray)\n        assert len(similarities) == 2\n        assert all(0.0 <= sim <= 1.0 for sim in similarities)\n    \n    def test_calculate_confidence(self, quantum_service):\n        \"\"\"Test confidence calculation\"\"\"\n        # Clear winner\n        kernel_values = np.array([0.1, 0.9, 0.2])\n        confidence = quantum_service._calculate_confidence(kernel_values, 1)\n        assert confidence > 0.5  # High confidence for clear winner\n        \n        # Close competition\n        kernel_values = np.array([0.45, 0.5, 0.48])\n        confidence = quantum_service._calculate_confidence(kernel_values, 1)\n        assert confidence < 0.3  # Low confidence for close competition\n        \n        # Single candidate\n        kernel_values = np.array([0.8])\n        confidence = quantum_service._calculate_confidence(kernel_values, 0)\n        assert confidence == 1.0  # Perfect confidence for single candidate\n    \n    @pytest.mark.asyncio\n    async def test_quantum_collapse_with_hardware(self, quantum_service):\n        \"\"\"Test quantum collapse with simulated hardware\"\"\"\n        request = CollapseRequest(\n            seed_vector=[0.5, 0.3, 0.8],\n            candidate_vectors=[\n                [0.6, 0.2, 0.7],\n                [0.4, 0.5, 0.6]\n            ],\n            use_hardware=True,  # Try hardware but will fallback\n            max_shots=1000\n        )\n        \n        result = await quantum_service.perform_collapse(request)\n        \n        assert isinstance(result, CollapseResponse)\n        assert result.success is True\n        assert 0 <= result.selected_index < 2\n        assert len(result.quantum_kernel) == 2\n    \n    @pytest.mark.asyncio\n    async def test_health_check(self, quantum_service):\n        \"\"\"Test service health check\"\"\"\n        health = await quantum_service.health_check()\n        assert isinstance(health, bool)\n        # Should be True in test environment with fallback enabled\n    \n    @pytest.mark.asyncio\n    async def test_get_metrics(self, quantum_service):\n        \"\"\"Test metrics collection\"\"\"\n        # Perform a collapse first to generate some metrics\n        request = CollapseRequest(\n            seed_vector=[0.5, 0.5],\n            candidate_vectors=[[0.6, 0.4]],\n            use_hardware=False\n        )\n        await quantum_service.perform_collapse(request)\n        \n        metrics = await quantum_service.get_metrics()\n        \n        assert 'total_requests' in metrics\n        assert 'successful_collapses' in metrics\n        assert 'hardware_executions' in metrics\n        assert 'success_rate' in metrics\n        assert 'average_processing_time' in metrics\n        assert metrics['total_requests'] >= 1\n    \n    @pytest.mark.asyncio\n    async def test_large_vector_handling(self, quantum_service):\n        \"\"\"Test handling of large vectors\"\"\"\n        # Create large vectors\n        seed_vector = np.random.rand(100).tolist()\n        candidate_vectors = [np.random.rand(100).tolist() for _ in range(5)]\n        \n        request = CollapseRequest(\n            seed_vector=seed_vector,\n            candidate_vectors=candidate_vectors,\n            use_hardware=False\n        )\n        \n        result = await quantum_service.perform_collapse(request)\n        \n        assert isinstance(result, CollapseResponse)\n        assert result.success is True\n        assert 0 <= result.selected_index < 5\n        assert len(result.quantum_kernel) == 5\n    \n    @pytest.mark.asyncio\n    async def test_edge_cases(self, quantum_service):\n        \"\"\"Test various edge cases\"\"\"\n        # Single candidate\n        request = CollapseRequest(\n            seed_vector=[0.5, 0.5],\n            candidate_vectors=[[0.6, 0.4]],\n            use_hardware=False\n        )\n        \n        result = await quantum_service.perform_collapse(request)\n        assert result.selected_index == 0\n        assert result.confidence == 1.0  # Perfect confidence with single candidate\n        \n        # Identical vectors\n        request = CollapseRequest(\n            seed_vector=[0.5, 0.5],\n            candidate_vectors=[[0.5, 0.5], [0.5, 0.5]],\n            use_hardware=False\n        )\n        \n        result = await quantum_service.perform_collapse(request)\n        assert 0 <= result.selected_index < 2\n        # Confidence should be low due to identical similarity\n    \n    def test_timestamp_generation(self, quantum_service):\n        \"\"\"Test timestamp generation\"\"\"\n        timestamp = quantum_service._get_timestamp()\n        assert isinstance(timestamp, str)\n        assert timestamp.endswith('Z')  # ISO format with UTC\n        assert 'T' in timestamp  # ISO format separator\n\n\nclass TestHardwareService:\n    \"\"\"Test cases for HardwareService\"\"\"\n    \n    @pytest.fixture\n    def hardware_service(self):\n        \"\"\"Create a hardware service instance for testing\"\"\"\n        return HardwareService()\n    \n    @pytest.mark.asyncio\n    async def test_initialize(self, hardware_service):\n        \"\"\"Test hardware service initialization\"\"\"\n        # Should not raise exception\n        await hardware_service.initialize()\n    \n    @pytest.mark.asyncio\n    async def test_get_status(self, hardware_service):\n        \"\"\"Test hardware status retrieval\"\"\"\n        status = await hardware_service.get_status()\n        \n        assert 'status' in status\n        assert 'hardware_available' in status\n        assert 'device' in status\n        assert 'max_shots' in status\n        assert 'max_wires' in status\n        assert 'devices' in status\n    \n    @pytest.mark.asyncio\n    async def test_device_connection_test(self, hardware_service):\n        \"\"\"Test device connection testing\"\"\"\n        result = await hardware_service.test_device_connection(\"local_simulator\")\n        \n        assert 'success' in result\n        assert 'device' in result\n        assert 'latency' in result\n        assert 'message' in result\n        \n        # Local simulator should always be available\n        assert result['success'] is True\n        assert result['device'] == 'local_simulator'\n    \n    @pytest.mark.asyncio\n    async def test_validate_parameters(self, hardware_service):\n        \"\"\"Test parameter validation\"\"\"\n        result = await hardware_service.validate_parameters(\n            wires=4,\n            shots=100\n        )\n        \n        assert 'valid' in result\n        assert 'adjusted_wires' in result\n        assert 'adjusted_shots' in result\n        \n        # Valid parameters should pass through unchanged\n        assert result['adjusted_wires'] == 4\n        assert result['adjusted_shots'] == 100\n        \n        # Test parameter adjustment\n        result = await hardware_service.validate_parameters(\n            wires=20,  # Too many\n            shots=100000  # Too many\n        )\n        \n        # Should be adjusted down\n        assert result['adjusted_wires'] <= 16\n        assert len(result.get('warnings', [])) > 0\n    \n    @pytest.mark.asyncio\n    async def test_get_recommended_device(self, hardware_service):\n        \"\"\"Test device recommendation\"\"\"\n        # Small circuit - should recommend simulator\n        device = await hardware_service.get_recommended_device(wires=4, shots=100)\n        assert device in ['local_simulator', 'fock_simulator']\n        \n        # Large circuit - should recommend simulator\n        device = await hardware_service.get_recommended_device(wires=16, shots=1000)\n        assert device == 'local_simulator'\n    \n    def test_cache_management(self, hardware_service):\n        \"\"\"Test cache clearing\"\"\"\n        # Should not raise exception\n        hardware_service.clear_cache()\n        \n        # Status should be None after clearing\n        assert hardware_service.cached_status is None\n        assert hardware_service.last_status_check is None\n    \n    @pytest.mark.asyncio\n    async def test_cleanup(self, hardware_service):\n        \"\"\"Test service cleanup\"\"\"\n        # Should not raise exception\n        await hardware_service.cleanup()\n\n\nclass TestIntegration:\n    \"\"\"Integration tests for quantum services\"\"\"\n    \n    @pytest.fixture\n    def services(self):\n        \"\"\"Create service instances for integration testing\"\"\"\n        return {\n            'quantum': QuantumService(),\n            'hardware': HardwareService()\n        }\n    \n    @pytest.mark.asyncio\n    async def test_end_to_end_collapse(self, services):\n        \"\"\"Test complete end-to-end quantum collapse\"\"\"\n        request = CollapseRequest(\n            seed_vector=[0.5, 0.3, 0.8],\n            candidate_vectors=[\n                [0.6, 0.2, 0.7],\n                [0.4, 0.5, 0.6],\n                [0.3, 0.4, 0.5]\n            ],\n            use_hardware=False,\n            max_shots=100,\n            method=\"kernel_fidelity\"\n        )\n        \n        # Get hardware status first\n        hardware_status = await services['hardware'].get_status()\n        assert 'status' in hardware_status\n        \n        # Perform collapse\n        result = await services['quantum'].perform_collapse(request)\n        \n        assert isinstance(result, CollapseResponse)\n        assert result.success is True\n        assert 0 <= result.selected_index < 3\n        assert 0.0 <= result.confidence <= 1.0\n        assert len(result.quantum_kernel) == 3\n        assert result.processing_time > 0\n        assert result.device in ['local_simulator', 'fock_simulator', 'error']\n    \n    @pytest.mark.asyncio\n    async def test_service_health_checks(self, services):\n        \"\"\"Test health checks for all services\"\"\"\n        quantum_health = await services['quantum'].health_check()\n        assert isinstance(quantum_health, bool)\n        \n        hardware_status = await services['hardware'].get_status()\n        assert hardware_status['status'] in ['operational', 'simulation_only', 'error']\n    \n    @pytest.mark.asyncio\n    async def test_metrics_collection(self, services):\n        \"\"\"Test metrics collection across services\"\"\"\n        # Perform some operations first\n        request = CollapseRequest(\n            seed_vector=[0.5, 0.5],\n            candidate_vectors=[[0.6, 0.4], [0.4, 0.6]],\n            use_hardware=False\n        )\n        \n        await services['quantum'].perform_collapse(request)\n        \n        # Collect metrics\n        quantum_metrics = await services['quantum'].get_metrics()\n        hardware_status = await services['hardware'].get_status()\n        \n        assert 'total_requests' in quantum_metrics\n        assert quantum_metrics['total_requests'] >= 1\n        assert 'hardware_available' in hardware_status\n\n\n# Parametrized tests\n@pytest.mark.parametrize(\"seed_dim,num_candidates\", [\n    (2, 1),\n    (2, 5),\n    (4, 3),\n    (8, 2),\n    (16, 4)\n])\n@pytest.mark.asyncio\nasync def test_various_dimensions(seed_dim, num_candidates):\n    \"\"\"Test quantum collapse with various vector dimensions\"\"\"\n    quantum_service = QuantumService()\n    \n    seed_vector = np.random.rand(seed_dim).tolist()\n    candidate_vectors = [np.random.rand(seed_dim).tolist() for _ in range(num_candidates)]\n    \n    request = CollapseRequest(\n        seed_vector=seed_vector,\n        candidate_vectors=candidate_vectors,\n        use_hardware=False\n    )\n    \n    result = await quantum_service.perform_collapse(request)\n    \n    assert result.success is True\n    assert 0 <= result.selected_index < num_candidates\n    assert len(result.quantum_kernel) == num_candidates\n\n\n@pytest.mark.parametrize(\"method\", [\n    \"kernel_fidelity\",\n    \"amplitude_encoding\", \n    \"angle_encoding\"\n])\n@pytest.mark.asyncio\nasync def test_different_methods(method):\n    \"\"\"Test quantum collapse with different methods\"\"\"\n    quantum_service = QuantumService()\n    \n    request = CollapseRequest(\n        seed_vector=[0.5, 0.5],\n        candidate_vectors=[[0.6, 0.4], [0.4, 0.6]],\n        use_hardware=False,\n        method=method\n    )\n    \n    result = await quantum_service.perform_collapse(request)\n    \n    assert result.success is True\n    assert result.method == method\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__])\n"