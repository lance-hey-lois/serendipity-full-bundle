import { quantumCollapseService } from '../../frontend/lib/quantum/collapse-service';\nimport { quantumHardwareService } from '../../frontend/lib/quantum/hardware-service';\nimport { validateQuantumRequest, normalizeVector } from '../../frontend/lib/quantum/utils';\nimport type { CollapseRequest } from '../../frontend/types/quantum';\n\n// Mock fetch globally\nglobal.fetch = jest.fn();\n\ndescribe('Quantum Collapse Service', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    (fetch as jest.Mock).mockClear();\n  });\n\n  describe('performCollapse', () => {\n    it('should perform quantum collapse with valid request', async () => {\n      const mockResponse = {\n        selected_index: 1,\n        confidence: 0.85,\n        quantum_kernel: [0.3, 0.7, 0.2],\n        hardware_used: false,\n        shots: 0,\n        device: 'local_simulator',\n        method: 'kernel_fidelity'\n      };\n\n      (fetch as jest.Mock).mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockResponse\n      });\n\n      const request: CollapseRequest = {\n        seedVector: [0.5, 0.5],\n        candidateVectors: [[0.6, 0.4], [0.7, 0.3], [0.4, 0.6]]\n      };\n\n      const result = await quantumCollapseService.performCollapse(request);\n\n      expect(result.selectedIndex).toBe(1);\n      expect(result.confidence).toBe(0.85);\n      expect(result.quantumKernel).toHaveLength(3);\n      expect(result.hardwareUsed).toBe(false);\n    });\n\n    it('should fallback to local processing when backend fails', async () => {\n      // Mock backend failure\n      (fetch as jest.Mock).mockRejectedValue(new Error('Backend unavailable'));\n\n      const request: CollapseRequest = {\n        seedVector: [0.5, 0.5],\n        candidateVectors: [[0.6, 0.4], [0.4, 0.6]],\n        useHardware: false\n      };\n\n      const result = await quantumCollapseService.performCollapse(request);\n\n      expect(result.selectedIndex).toBeGreaterThanOrEqual(0);\n      expect(result.selectedIndex).toBeLessThan(2);\n      expect(result.confidence).toBeGreaterThanOrEqual(0);\n      expect(result.confidence).toBeLessThanOrEqual(1);\n    });\n\n    it('should validate request parameters', async () => {\n      const invalidRequest: CollapseRequest = {\n        seedVector: [],  // Invalid: empty\n        candidateVectors: [[0.6, 0.4]]\n      };\n\n      await expect(quantumCollapseService.performCollapse(invalidRequest))\n        .rejects.toThrow('Invalid seed vector');\n    });\n\n    it('should handle dimension mismatch', async () => {\n      const invalidRequest: CollapseRequest = {\n        seedVector: [0.5, 0.5],\n        candidateVectors: [[0.6, 0.4, 0.2]]  // Invalid: different dimension\n      };\n\n      await expect(quantumCollapseService.performCollapse(invalidRequest))\n        .rejects.toThrow('dimension mismatch');\n    });\n  });\n\n  describe('health check', () => {\n    it('should return true for healthy service', async () => {\n      const health = await quantumCollapseService.healthCheck();\n      expect(typeof health).toBe('boolean');\n    });\n  });\n});\n\ndescribe('Hardware Service', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    (fetch as jest.Mock).mockClear();\n  });\n\n  describe('getHardwareStatus', () => {\n    it('should return hardware status', async () => {\n      const mockStatus = {\n        hardware_available: false,\n        device: 'local_simulator',\n        authenticated: false,\n        api_key_set: false,\n        max_shots: 1000,\n        max_wires: 8,\n        devices: [],\n        last_check: new Date().toISOString()\n      };\n\n      (fetch as jest.Mock).mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockStatus\n      });\n\n      const status = await quantumHardwareService.getHardwareStatus();\n\n      expect(status.hardwareAvailable).toBe(false);\n      expect(status.device).toBe('local_simulator');\n      expect(status.maxShots).toBe(1000);\n    });\n\n    it('should fallback when backend unavailable', async () => {\n      (fetch as jest.Mock).mockRejectedValue(new Error('Backend unavailable'));\n\n      const status = await quantumHardwareService.getHardwareStatus();\n\n      expect(status).toHaveProperty('hardwareAvailable');\n      expect(status).toHaveProperty('device');\n    });\n  });\n\n  describe('testHardwareConnection', () => {\n    it('should test device connection', async () => {\n      const mockResponse = {\n        success: true,\n        device: 'X8',\n        latency: 150\n      };\n\n      (fetch as jest.Mock).mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockResponse\n      });\n\n      const result = await quantumHardwareService.testHardwareConnection('X8');\n\n      expect(result.success).toBe(true);\n      expect(result.device).toBe('X8');\n      expect(result.latency).toBe(150);\n    });\n  });\n});\n\ndescribe('Quantum Utils', () => {\n  describe('validateQuantumRequest', () => {\n    it('should validate correct request', () => {\n      const request = {\n        seedVector: [0.5, 0.5],\n        candidateVectors: [[0.6, 0.4], [0.4, 0.6]],\n        useHardware: true,\n        maxShots: 1000\n      };\n\n      const result = validateQuantumRequest(request);\n      expect(result.valid).toBe(true);\n    });\n\n    it('should reject empty seed vector', () => {\n      const request = {\n        seedVector: [],\n        candidateVectors: [[0.6, 0.4]]\n      };\n\n      const result = validateQuantumRequest(request);\n      expect(result.valid).toBe(false);\n      expect(result.message).toContain('seedVector');\n    });\n\n    it('should reject invalid shots parameter', () => {\n      const request = {\n        seedVector: [0.5, 0.5],\n        candidateVectors: [[0.6, 0.4]],\n        maxShots: -1\n      };\n\n      const result = validateQuantumRequest(request);\n      expect(result.valid).toBe(false);\n      expect(result.message).toContain('maxShots');\n    });\n\n    it('should reject non-finite values', () => {\n      const request = {\n        seedVector: [0.5, NaN],\n        candidateVectors: [[0.6, 0.4]]\n      };\n\n      const result = validateQuantumRequest(request);\n      expect(result.valid).toBe(false);\n    });\n  });\n\n  describe('normalizeVector', () => {\n    it('should normalize vector to unit length', () => {\n      const vector = [3, 4];  // Length = 5\n      const normalized = normalizeVector(vector);\n      \n      expect(normalized[0]).toBeCloseTo(0.6);\n      expect(normalized[1]).toBeCloseTo(0.8);\n      \n      // Check unit length\n      const length = Math.sqrt(normalized[0] ** 2 + normalized[1] ** 2);\n      expect(length).toBeCloseTo(1);\n    });\n\n    it('should handle zero vector', () => {\n      const vector = [0, 0];\n      const normalized = normalizeVector(vector);\n      \n      expect(normalized).toEqual([0, 0]);\n    });\n\n    it('should handle single element vector', () => {\n      const vector = [5];\n      const normalized = normalizeVector(vector);\n      \n      expect(normalized[0]).toBeCloseTo(1);\n    });\n  });\n});\n\n// Integration tests\ndescribe('Quantum Integration', () => {\n  it('should perform end-to-end quantum collapse', async () => {\n    // Mock successful backend response\n    (fetch as jest.Mock).mockResolvedValueOnce({\n      ok: true,\n      json: async () => ({\n        selected_index: 0,\n        confidence: 0.75,\n        quantum_kernel: [0.8, 0.6, 0.4],\n        hardware_used: false,\n        shots: 0,\n        device: 'local_simulator',\n        method: 'kernel_fidelity'\n      })\n    });\n\n    const request: CollapseRequest = {\n      seedVector: [0.5, 0.3, 0.8],\n      candidateVectors: [\n        [0.6, 0.2, 0.7],\n        [0.4, 0.5, 0.6],\n        [0.3, 0.4, 0.5]\n      ],\n      useHardware: false,\n      maxShots: 100\n    };\n\n    const result = await quantumCollapseService.performCollapse(request);\n\n    expect(result).toBeDefined();\n    expect(result.selectedIndex).toBeGreaterThanOrEqual(0);\n    expect(result.selectedIndex).toBeLessThan(3);\n    expect(result.confidence).toBeGreaterThan(0);\n    expect(result.quantumKernel).toHaveLength(3);\n  });\n\n  it('should handle large vector dimensions', async () => {\n    // Test with larger vectors (up to the limit)\n    const seedVector = Array(100).fill(0).map((_, i) => Math.sin(i * 0.1));\n    const candidateVectors = [\n      Array(100).fill(0).map((_, i) => Math.cos(i * 0.1)),\n      Array(100).fill(0).map((_, i) => Math.sin(i * 0.15))\n    ];\n\n    const request: CollapseRequest = {\n      seedVector,\n      candidateVectors,\n      useHardware: false\n    };\n\n    // Should not throw for valid large vectors\n    const validation = validateQuantumRequest(request);\n    expect(validation.valid).toBe(true);\n  });\n});\n"