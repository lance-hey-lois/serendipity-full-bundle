/**\n * TypeScript type definitions for Quantum Collapse Kit\n */\n\n// Core Request/Response Types\nexport interface CollapseRequest {\n  seedVector: number[];\n  candidateVectors: number[][];\n  useHardware?: boolean;\n  maxShots?: number;\n  method?: 'kernel_fidelity' | 'amplitude_encoding' | 'angle_encoding';\n  devicePreference?: string;\n}\n\nexport interface CollapseResult {\n  selectedIndex: number;\n  confidence: number;\n  quantumKernel: number[];\n  hardwareUsed: boolean;\n  shots: number;\n  device: string;\n  method: string;\n}\n\nexport interface CollapseResponse {\n  success: boolean;\n  result: {\n    selectedIndex: number;\n    confidence: number;\n    quantumKernel: number[];\n    hardwareUsed: boolean;\n    processingTime: number;\n    metadata: {\n      timestamp: string;\n      shots: number;\n      device: string;\n      method: string;\n    };\n  };\n}\n\n// Error Types\nexport interface QuantumError {\n  error: string;\n  message: string;\n  timestamp: string;\n  details?: any;\n}\n\n// Hardware Status Types\nexport interface DeviceInfo {\n  name: string;\n  type: 'photonic' | 'simulator' | 'gate';\n  wires: number;\n  available: boolean;\n  queue_size: number;\n  specifications?: {\n    cutoff_dim?: number;\n    max_shots?: number;\n    connectivity?: string;\n    error_rate?: number;\n  };\n}\n\nexport interface HardwareStatus {\n  hardwareAvailable: boolean;\n  device: string;\n  authenticated: boolean;\n  apiKeySet: boolean;\n  maxShots: number;\n  maxWires: number;\n  devices: DeviceInfo[];\n  lastCheck: string;\n  status: 'online' | 'offline' | 'maintenance' | 'error';\n  latency?: number;\n  errorMessage?: string;\n}\n\n// Quantum Kernel Types\nexport interface QuantumKernelResult {\n  values: number[];\n  hardwareUsed: boolean;\n  device: string;\n  shots: number;\n  processingTime?: number;\n  statistics?: {\n    mean: number;\n    std: number;\n    min: number;\n    max: number;\n    entropy: number;\n  };\n}\n\n// Circuit Types\nexport interface QuantumCircuit {\n  wires: number;\n  depth: number;\n  gates: QuantumGate[];\n  measurements: number[];\n}\n\nexport interface QuantumGate {\n  name: string;\n  wires: number[];\n  parameters?: number[];\n  classical_control?: number[];\n}\n\n// Execution Types\nexport interface ExecutionJob {\n  id: string;\n  status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';\n  createdAt: string;\n  startedAt?: string;\n  completedAt?: string;\n  device: string;\n  shots: number;\n  circuit: QuantumCircuit;\n  results?: ExecutionResult;\n  error?: string;\n}\n\nexport interface ExecutionResult {\n  counts?: { [state: string]: number };\n  probabilities?: number[];\n  amplitudes?: Complex[];\n  expectation_values?: number[];\n  samples?: number[][];\n  fidelity?: number;\n}\n\nexport interface Complex {\n  real: number;\n  imag: number;\n}\n\n// Configuration Types\nexport interface QuantumConfig {\n  defaultDevice: string;\n  maxRetries: number;\n  timeout: number;\n  fallbackEnabled: boolean;\n  hardwarePreferred: boolean;\n  cacheEnabled: boolean;\n  logLevel: 'debug' | 'info' | 'warn' | 'error';\n}\n\n// Analytics Types\nexport interface QuantumMetrics {\n  totalExecutions: number;\n  hardwareExecutions: number;\n  simulatorExecutions: number;\n  averageLatency: number;\n  successRate: number;\n  errorRate: number;\n  mostUsedDevice: string;\n  totalProcessingTime: number;\n}\n\n// Event Types\nexport interface QuantumEvent {\n  type: 'execution_started' | 'execution_completed' | 'execution_failed' | 'device_status_changed';\n  timestamp: string;\n  data: any;\n}\n\n// Subscription Types\nexport interface QuantumSubscription {\n  id: string;\n  eventTypes: string[];\n  callback: (event: QuantumEvent) => void;\n  active: boolean;\n}\n\n// Batch Processing Types\nexport interface BatchCollapseRequest {\n  requests: CollapseRequest[];\n  parallelExecution?: boolean;\n  maxConcurrency?: number;\n  failureStrategy?: 'abort' | 'continue' | 'retry';\n}\n\nexport interface BatchCollapseResponse {\n  success: boolean;\n  results: (CollapseResult | QuantumError)[];\n  totalProcessingTime: number;\n  successCount: number;\n  failureCount: number;\n  metadata: {\n    timestamp: string;\n    batchId: string;\n    executionStrategy: string;\n  };\n}\n\n// Optimization Types\nexport interface OptimizationRequest {\n  objectiveFunction: string; // Python code or predefined function name\n  parameters: OptimizationParameter[];\n  constraints?: OptimizationConstraint[];\n  method?: 'QAOA' | 'VQE' | 'COBYLA' | 'SPSA';\n  maxIterations?: number;\n  tolerance?: number;\n}\n\nexport interface OptimizationParameter {\n  name: string;\n  type: 'continuous' | 'discrete';\n  bounds: [number, number];\n  initialValue?: number;\n}\n\nexport interface OptimizationConstraint {\n  type: 'equality' | 'inequality';\n  expression: string;\n  tolerance?: number;\n}\n\nexport interface OptimizationResult {\n  success: boolean;\n  optimalParameters: { [name: string]: number };\n  optimalValue: number;\n  iterations: number;\n  converged: boolean;\n  optimizationHistory: {\n    iteration: number;\n    parameters: { [name: string]: number };\n    value: number;\n    gradient?: number[];\n  }[];\n}\n\n// Machine Learning Integration Types\nexport interface QuantumMLModel {\n  id: string;\n  name: string;\n  type: 'QNN' | 'QSVM' | 'QBoltzmann' | 'QGAN';\n  parameters: { [key: string]: number };\n  architecture: QuantumCircuit;\n  trained: boolean;\n  accuracy?: number;\n  trainingHistory?: TrainingEpoch[];\n}\n\nexport interface TrainingEpoch {\n  epoch: number;\n  loss: number;\n  accuracy: number;\n  validationLoss?: number;\n  validationAccuracy?: number;\n  processingTime: number;\n}\n\n// Advanced Quantum Types\nexport interface QuantumState {\n  amplitudes: Complex[];\n  probabilities: number[];\n  entanglement?: EntanglementMeasure;\n  purity?: number;\n  fidelity?: number;\n}\n\nexport interface EntanglementMeasure {\n  type: 'concurrence' | 'negativity' | 'entropy';\n  value: number;\n  qubits: number[];\n}\n\n// Networking Types\nexport interface QuantumNetworkNode {\n  id: string;\n  address: string;\n  capabilities: string[];\n  status: 'online' | 'offline' | 'busy';\n  lastHeartbeat: string;\n}\n\nexport interface DistributedQuantumJob {\n  id: string;\n  nodes: string[];\n  subtasks: QuantumSubtask[];\n  aggregationMethod: 'average' | 'majority' | 'weighted';\n  status: 'pending' | 'distributed' | 'collecting' | 'completed' | 'failed';\n}\n\nexport interface QuantumSubtask {\n  id: string;\n  nodeId: string;\n  circuit: QuantumCircuit;\n  status: 'pending' | 'running' | 'completed' | 'failed';\n  result?: ExecutionResult;\n  error?: string;\n}\n\n// Utility Types\nexport type QuantumOperation = 'collapse' | 'optimize' | 'train' | 'execute' | 'simulate';\nexport type DeviceType = 'hardware' | 'simulator' | 'hybrid';\nexport type ExecutionMode = 'sync' | 'async' | 'streaming';\nexport type ResultFormat = 'json' | 'numpy' | 'qiskit' | 'cirq';\n\n// Configuration Schemas\nexport interface APIConfiguration {\n  baseURL: string;\n  timeout: number;\n  retries: number;\n  authentication: {\n    type: 'bearer' | 'api_key' | 'oauth';\n    credentials: string;\n  };\n  rateLimit?: {\n    requests: number;\n    window: number; // in seconds\n  };\n}\n\n// Monitoring Types\nexport interface SystemHealth {\n  overall: 'healthy' | 'degraded' | 'unhealthy';\n  components: {\n    api: boolean;\n    hardware: boolean;\n    database: boolean;\n    cache: boolean;\n  };\n  metrics: {\n    uptime: number;\n    responseTime: number;\n    errorRate: number;\n    throughput: number;\n  };\n  timestamp: string;\n}\n\n// Export all types as a namespace for convenience\nexport namespace Quantum {\n  export type Request = CollapseRequest;\n  export type Response = CollapseResponse;\n  export type Result = CollapseResult;\n  export type Error = QuantumError;\n  export type Hardware = HardwareStatus;\n  export type Device = DeviceInfo;\n  export type Config = QuantumConfig;\n  export type Metrics = QuantumMetrics;\n  export type Circuit = QuantumCircuit;\n  export type Job = ExecutionJob;\n  export type State = QuantumState;\n}\n"